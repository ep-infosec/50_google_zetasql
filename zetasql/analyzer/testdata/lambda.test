SELECT LENGTH([1,2], e->e>0);
--
ERROR: Lambda is not supported [at 1:22]
SELECT LENGTH([1,2], e->e>0);
                     ^
==

[default language_features=V_1_3_INLINE_LAMBDA_ARGUMENT,NAMED_ARGUMENTS]
SELECT e -> e > 0;
--
ERROR: Syntax error: Expected end of input but got "->" [at 1:10]
SELECT e -> e > 0;
         ^
==

# Call a lambda
SELECT (e -> e > 0)(1);
--
ERROR: Syntax error: Parenthesized expression cannot be parsed as an expression, struct constructor, or subquery [at 1:9]
SELECT (e -> e > 0)(1);
        ^
==

SELECT LENGTH([1,2], e.e -> e.e > 0) AS a_1;
--
ERROR: Lambda argument name must be a single identifier [at 1:22]
SELECT LENGTH([1,2], e.e -> e.e > 0) AS a_1;
                     ^
==

SELECT LENGTH([2], 1 -> 1 > 0) AS a_1;
--
ERROR: Syntax error: Expecting lambda argument list [at 1:20]
SELECT LENGTH([2], 1 -> 1 > 0) AS a_1;
                   ^
==

SELECT LENGTH([2], (e, LENGTH("a")) -> e > 0) AS a_1;
--
ERROR: Lambda argument name must be a single identifier [at 1:24]
SELECT LENGTH([2], (e, LENGTH("a")) -> e > 0) AS a_1;
                       ^
==

SELECT LENGTH([2], (e, (f, g)) -> 1 > 0) AS a_1;
--
ERROR: Lambda argument name must be a single identifier [at 1:24]
SELECT LENGTH([2], (e, (f, g)) -> 1 > 0) AS a_1;
                       ^
==

SELECT LENGTH([2], (SELECT 1) -> e.e > 0) AS a_1;
--
ERROR: Syntax error: Expecting lambda argument list [at 1:20]
SELECT LENGTH([2], (SELECT 1) -> e.e > 0) AS a_1;
                   ^
==

SELECT LENGTH([2], (e, (SELECT 1)) -> e > 0) AS a_1;
--
ERROR: Lambda argument name must be a single identifier [at 1:24]
SELECT LENGTH([2], (e, (SELECT 1)) -> e > 0) AS a_1;
                       ^
==

SELECT LENGTH([1,2], (e.e) -> e > 0) AS a_1;
--
ERROR: Lambda argument name must be a single identifier [at 1:23]
SELECT LENGTH([1,2], (e.e) -> e > 0) AS a_1;
                      ^
==

SELECT LENGTH([1,2], (e, e.e) -> e > 0) AS a_1;
--
ERROR: Lambda argument name must be a single identifier [at 1:26]
SELECT LENGTH([1,2], (e, e.e) -> e > 0) AS a_1;
                         ^
==

SELECT LENGTH([1,2], (e, e.e) -> e > 0) AS a_1;
--
ERROR: Lambda argument name must be a single identifier [at 1:26]
SELECT LENGTH([1,2], (e, e.e) -> e > 0) AS a_1;
                         ^
==

SELECT LENGTH([1,2], (e, e>0) -> e > 0) AS a_1;
--
ERROR: Lambda argument name must be a single identifier [at 1:26]
SELECT LENGTH([1,2], (e, e>0) -> e > 0) AS a_1;
                         ^
==

# NULL cannot be used for lambda
SELECT fn_array_filter(ARRAY<INT64>[1, 2], NULL) AS a_1;
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ARRAY_FILTER for argument types: ARRAY<INT64>, NULL. Supported signatures: FN_ARRAY_FILTER(ARRAY, LAMBDA(ANY->BOOL)); FN_ARRAY_FILTER(ARRAY, LAMBDA((ANY, INT64)->BOOL)) [at 1:8]
SELECT fn_array_filter(ARRAY<INT64>[1, 2], NULL) AS a_1;
       ^
==

# Lambda body mismatch
# TODO: Enhance the error msg with why each signature doesn't match.
SELECT fn_array_filter(ARRAY<INT64>[1, 2], e->e+1) AS a_1;
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ARRAY_FILTER for argument types: ARRAY<INT64>, LAMBDA. Supported signatures: FN_ARRAY_FILTER(ARRAY, LAMBDA(ANY->BOOL)); FN_ARRAY_FILTER(ARRAY, LAMBDA((ANY, INT64)->BOOL)) [at 1:8]
SELECT fn_array_filter(ARRAY<INT64>[1, 2], e->e+1) AS a_1;
       ^
==

# No matching signature for transform.
SELECT fn_array_filter(1, (e, i) -> e > i);
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ARRAY_FILTER for argument types: INT64, LAMBDA. Supported signatures: FN_ARRAY_FILTER(ARRAY, LAMBDA(ANY->BOOL)); FN_ARRAY_FILTER(ARRAY, LAMBDA((ANY, INT64)->BOOL)) [at 1:8]
SELECT fn_array_filter(1, (e, i) -> e > i);
       ^
==

SELECT fn_array_filter(ARRAY<INT64>[1, 2], (e, e)->e+1) AS a_1;
--
ERROR: Lambda argument name `e` is already defined [at 1:48]
SELECT fn_array_filter(ARRAY<INT64>[1, 2], (e, e)->e+1) AS a_1;
                                               ^
==

# A typed NULL array is a match.
SELECT fn_array_filter(CAST(NULL AS ARRAY<INT64>), e -> e > 0) AS a_1;
--
QueryStmt
+-output_column_list=
| +-$query.a_1#2 AS a_1 [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.a_1#2]
    +-expr_list=
    | +-a_1#2 :=
    |   +-FunctionCall(sample_functions:fn_array_filter(ARRAY<INT64>, LAMBDA(INT64->BOOL)) -> ARRAY<INT64>)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=ARRAY<INT64>, value=NULL, has_explicit_type=TRUE)
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=[$lambda_arg.e#1]
    |           +-body=
    |             +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |               +-ColumnRef(type=INT64, column=$lambda_arg.e#1)
    |               +-Literal(type=INT64, value=0)
    +-input_scan=
      +-SingleRowScan
==

# A typed empty array is a match.
SELECT fn_array_filter(ARRAY<INT64>[], e -> e > 0) AS a_1;
--
QueryStmt
+-output_column_list=
| +-$query.a_1#2 AS a_1 [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.a_1#2]
    +-expr_list=
    | +-a_1#2 :=
    |   +-FunctionCall(sample_functions:fn_array_filter(ARRAY<INT64>, LAMBDA(INT64->BOOL)) -> ARRAY<INT64>)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=ARRAY<INT64>, value=[], has_explicit_type=TRUE)
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=[$lambda_arg.e#1]
    |           +-body=
    |             +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |               +-ColumnRef(type=INT64, column=$lambda_arg.e#1)
    |               +-Literal(type=INT64, value=0)
    +-input_scan=
      +-SingleRowScan
==

SELECT fn_array_filter(null, e -> e > 0) AS a_1;
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ARRAY_FILTER for argument types: NULL, LAMBDA. Supported signatures: FN_ARRAY_FILTER(ARRAY, LAMBDA(ANY->BOOL)); FN_ARRAY_FILTER(ARRAY, LAMBDA((ANY, INT64)->BOOL)) [at 1:8]
SELECT fn_array_filter(null, e -> e > 0) AS a_1;
       ^
==

SELECT fn_array_filter([], e -> e > 0) AS a_1;
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ARRAY_FILTER for argument types: [], LAMBDA. Supported signatures: FN_ARRAY_FILTER(ARRAY, LAMBDA(ANY->BOOL)); FN_ARRAY_FILTER(ARRAY, LAMBDA((ANY, INT64)->BOOL)) [at 1:8]
SELECT fn_array_filter([], e -> e > 0) AS a_1;
       ^
==

SELECT fn_array_filter([1,2], e -> true);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#2 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#2]
    +-expr_list=
    | +-$col1#2 :=
    |   +-FunctionCall(sample_functions:fn_array_filter(ARRAY<INT64>, LAMBDA(INT64->BOOL)) -> ARRAY<INT64>)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=ARRAY<INT64>, value=[1, 2])
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=[$lambda_arg.e#1]
    |           +-body=
    |             +-Literal(type=BOOL, value=true)
    +-input_scan=
      +-SingleRowScan
==

SELECT fn_array_filter([1,2], e -> e > 0);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#2 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#2]
    +-expr_list=
    | +-$col1#2 :=
    |   +-FunctionCall(sample_functions:fn_array_filter(ARRAY<INT64>, LAMBDA(INT64->BOOL)) -> ARRAY<INT64>)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=ARRAY<INT64>, value=[1, 2])
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=[$lambda_arg.e#1]
    |           +-body=
    |             +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |               +-ColumnRef(type=INT64, column=$lambda_arg.e#1)
    |               +-Literal(type=INT64, value=0)
    +-input_scan=
      +-SingleRowScan
==

# Lambda body accessing columns other than the lambda arguments.
SELECT fn_array_filter([1,2], e -> e > Key) from KeyValue;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-FunctionCall(sample_functions:fn_array_filter(ARRAY<INT64>, LAMBDA(INT64->BOOL)) -> ARRAY<INT64>)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=ARRAY<INT64>, value=[1, 2])
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=[$lambda_arg.e#3]
    |           +-parameter_list=
    |           | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |           +-body=
    |             +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |               +-ColumnRef(type=INT64, column=$lambda_arg.e#3)
    |               +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    +-input_scan=
      +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])

==

# Both arguments of the function references the Key column.
SELECT fn_array_filter([kv.key, 3,4], e -> e > kv.Key) from KeyValue as kv;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-FunctionCall(sample_functions:fn_array_filter(ARRAY<INT64>, LAMBDA(INT64->BOOL)) -> ARRAY<INT64>)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-FunctionCall(ZetaSQL:$make_array(repeated(3) INT64) -> ARRAY<INT64>)
    |     |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     |     +-Literal(type=INT64, value=3)
    |     |     +-Literal(type=INT64, value=4)
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=[$lambda_arg.e#3]
    |           +-parameter_list=
    |           | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |           +-body=
    |             +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |               +-ColumnRef(type=INT64, column=$lambda_arg.e#3)
    |               +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    +-input_scan=
      +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
==

# Lambda inside lambda
SELECT fn_array_filter([1,2,3], e1 -> ARRAY_IS_DISTINCT(fn_array_filter([e1,3,4], e2->e2<e1)));
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-FunctionCall(sample_functions:fn_array_filter(ARRAY<INT64>, LAMBDA(INT64->BOOL)) -> ARRAY<INT64>)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=ARRAY<INT64>, value=[1, 2, 3])
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=[$lambda_arg.e1#1]
    |           +-body=
    |             +-FunctionCall(ZetaSQL:array_is_distinct(ARRAY<INT64>) -> BOOL)
    |               +-FunctionCall(sample_functions:fn_array_filter(ARRAY<INT64>, LAMBDA(INT64->BOOL)) -> ARRAY<INT64>)
    |                 +-FunctionArgument
    |                 | +-expr=
    |                 |   +-FunctionCall(ZetaSQL:$make_array(repeated(3) INT64) -> ARRAY<INT64>)
    |                 |     +-ColumnRef(type=INT64, column=$lambda_arg.e1#1)
    |                 |     +-Literal(type=INT64, value=3)
    |                 |     +-Literal(type=INT64, value=4)
    |                 +-FunctionArgument
    |                   +-inline_lambda=
    |                     +-InlineLambda
    |                       +-argument_list=[$lambda_arg.e2#2]
    |                       +-parameter_list=
    |                       | +-ColumnRef(type=INT64, column=$lambda_arg.e1#1)
    |                       +-body=
    |                         +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
    |                           +-ColumnRef(type=INT64, column=$lambda_arg.e2#2)
    |                           +-ColumnRef(type=INT64, column=$lambda_arg.e1#1, is_correlated=TRUE)
    +-input_scan=
      +-SingleRowScan
==

# Lambda inside lambda, inner lambda body referencing outside lambda argument
SELECT fn_array_filter([1,2,3], e1 -> e1 in UNNEST(fn_array_filter([2,3,4], e2->e2<e1)));
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-FunctionCall(sample_functions:fn_array_filter(ARRAY<INT64>, LAMBDA(INT64->BOOL)) -> ARRAY<INT64>)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=ARRAY<INT64>, value=[1, 2, 3])
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=[$lambda_arg.e1#1]
    |           +-body=
    |             +-FunctionCall(ZetaSQL:$in_array(INT64, ARRAY<INT64>) -> BOOL)
    |               +-ColumnRef(type=INT64, column=$lambda_arg.e1#1)
    |               +-FunctionCall(sample_functions:fn_array_filter(ARRAY<INT64>, LAMBDA(INT64->BOOL)) -> ARRAY<INT64>)
    |                 +-FunctionArgument
    |                 | +-expr=
    |                 |   +-Literal(type=ARRAY<INT64>, value=[2, 3, 4])
    |                 +-FunctionArgument
    |                   +-inline_lambda=
    |                     +-InlineLambda
    |                       +-argument_list=[$lambda_arg.e2#2]
    |                       +-parameter_list=
    |                       | +-ColumnRef(type=INT64, column=$lambda_arg.e1#1)
    |                       +-body=
    |                         +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
    |                           +-ColumnRef(type=INT64, column=$lambda_arg.e2#2)
    |                           +-ColumnRef(type=INT64, column=$lambda_arg.e1#1, is_correlated=TRUE)
    +-input_scan=
      +-SingleRowScan

==

# Lambda inside lambda, inner lambda argument shadowing outter lambda argument
SELECT fn_array_filter([1,2,3], e1 -> ARRAY_IS_DISTINCT(fn_array_filter([e1,3,4], e1->e1<0)));
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-FunctionCall(sample_functions:fn_array_filter(ARRAY<INT64>, LAMBDA(INT64->BOOL)) -> ARRAY<INT64>)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=ARRAY<INT64>, value=[1, 2, 3])
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=[$lambda_arg.e1#1]
    |           +-body=
    |             +-FunctionCall(ZetaSQL:array_is_distinct(ARRAY<INT64>) -> BOOL)
    |               +-FunctionCall(sample_functions:fn_array_filter(ARRAY<INT64>, LAMBDA(INT64->BOOL)) -> ARRAY<INT64>)
    |                 +-FunctionArgument
    |                 | +-expr=
    |                 |   +-FunctionCall(ZetaSQL:$make_array(repeated(3) INT64) -> ARRAY<INT64>)
    |                 |     +-ColumnRef(type=INT64, column=$lambda_arg.e1#1)
    |                 |     +-Literal(type=INT64, value=3)
    |                 |     +-Literal(type=INT64, value=4)
    |                 +-FunctionArgument
    |                   +-inline_lambda=
    |                     +-InlineLambda
    |                       +-argument_list=[$lambda_arg.e1#2]
    |                       +-body=
    |                         +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
    |                           +-ColumnRef(type=INT64, column=$lambda_arg.e1#2)
    |                           +-Literal(type=INT64, value=0)
    +-input_scan=
      +-SingleRowScan
==

# Lambda inside lambda, inner lambda argument shadowing outter column
SELECT fn_array_filter([1,2,Key], Key -> (Key > 0)) From KeyValue as e;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-FunctionCall(sample_functions:fn_array_filter(ARRAY<INT64>, LAMBDA(INT64->BOOL)) -> ARRAY<INT64>)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-FunctionCall(ZetaSQL:$make_array(repeated(3) INT64) -> ARRAY<INT64>)
    |     |     +-Literal(type=INT64, value=1)
    |     |     +-Literal(type=INT64, value=2)
    |     |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=[$lambda_arg.Key#3]
    |           +-body=
    |             +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |               +-ColumnRef(type=INT64, column=$lambda_arg.Key#3)
    |               +-Literal(type=INT64, value=0)
    +-input_scan=
      +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="e")
==

# Lambda inside lambda, inner lambda argument shadowing outter table
SELECT fn_array_filter([1,2,e.Key], e -> (e > 0)) From KeyValue as e;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-FunctionCall(sample_functions:fn_array_filter(ARRAY<INT64>, LAMBDA(INT64->BOOL)) -> ARRAY<INT64>)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-FunctionCall(ZetaSQL:$make_array(repeated(3) INT64) -> ARRAY<INT64>)
    |     |     +-Literal(type=INT64, value=1)
    |     |     +-Literal(type=INT64, value=2)
    |     |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=[$lambda_arg.e#3]
    |           +-body=
    |             +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |               +-ColumnRef(type=INT64, column=$lambda_arg.e#3)
    |               +-Literal(type=INT64, value=0)
    +-input_scan=
      +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="e")
==

# filter with array index.
SELECT fn_array_filter([1,2], (e, i) -> e > i);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-FunctionCall(sample_functions:fn_array_filter(ARRAY<INT64>, LAMBDA((INT64, INT64)->BOOL)) -> ARRAY<INT64>)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=ARRAY<INT64>, value=[1, 2])
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=$lambda_arg.[e#1, i#2]
    |           +-body=
    |             +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |               +-ColumnRef(type=INT64, column=$lambda_arg.e#1)
    |               +-ColumnRef(type=INT64, column=$lambda_arg.i#2)
    +-input_scan=
      +-SingleRowScan
==

# Simple transform
SELECT fn_array_transform([1,2], (e) -> e + 1 );
--
QueryStmt
+-output_column_list=
| +-$query.$col1#2 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#2]
    +-expr_list=
    | +-$col1#2 :=
    |   +-FunctionCall(sample_functions:fn_array_transform(ARRAY<INT64>, LAMBDA(INT64->INT64)) -> ARRAY<INT64>)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=ARRAY<INT64>, value=[1, 2])
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=[$lambda_arg.e#1]
    |           +-body=
    |             +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |               +-ColumnRef(type=INT64, column=$lambda_arg.e#1)
    |               +-Literal(type=INT64, value=1)
    +-input_scan=
      +-SingleRowScan
==

# No matching signature for transform
SELECT fn_array_transform(1, (e) -> e + 1 );
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ARRAY_TRANSFORM for argument types: INT64, LAMBDA. Supported signatures: FN_ARRAY_TRANSFORM(ARRAY, LAMBDA(ANY->ANY)); FN_ARRAY_TRANSFORM(ARRAY, LAMBDA((ANY, INT64)->ANY)) [at 1:8]
SELECT fn_array_transform(1, (e) -> e + 1 );
       ^
==

# Transform with index
SELECT fn_array_transform([1,2], (e, i) -> e + i);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-FunctionCall(sample_functions:fn_array_transform(ARRAY<INT64>, LAMBDA((INT64, INT64)->INT64)) -> ARRAY<INT64>)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=ARRAY<INT64>, value=[1, 2])
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=$lambda_arg.[e#1, i#2]
    |           +-body=
    |             +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |               +-ColumnRef(type=INT64, column=$lambda_arg.e#1)
    |               +-ColumnRef(type=INT64, column=$lambda_arg.i#2)
    +-input_scan=
      +-SingleRowScan
==

SELECT fn_fp_T_T_LAMBDA(1, 1, e->e>0);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#2 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#2]
    +-expr_list=
    | +-$col1#2 :=
    |   +-FunctionCall(sample_functions:fn_fp_T_T_LAMBDA(INT64, INT64, LAMBDA(INT64->BOOL)) -> INT64)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=INT64, value=1)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=INT64, value=1)
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=[$lambda_arg.e#1]
    |           +-body=
    |             +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |               +-ColumnRef(type=INT64, column=$lambda_arg.e#1)
    |               +-Literal(type=INT64, value=0)
    +-input_scan=
      +-SingleRowScan
==

# Signature: fn_fp_T_T_LAMBDA(T, T, T->BOOL)
# In this test, INT64 and DOUBLE are provided as template type T and INT64 is
# coerced to DOUBLE.
SELECT fn_fp_T_T_LAMBDA(Key, 1.0, e->e>0) FROM KeyValue;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-FunctionCall(sample_functions:fn_fp_T_T_LAMBDA(DOUBLE, DOUBLE, LAMBDA(DOUBLE->BOOL)) -> DOUBLE)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Cast(INT64 -> DOUBLE)
    |     |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=DOUBLE, value=1)
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=[$lambda_arg.e#3]
    |           +-body=
    |             +-FunctionCall(ZetaSQL:$greater(DOUBLE, DOUBLE) -> BOOL)
    |               +-ColumnRef(type=DOUBLE, column=$lambda_arg.e#3)
    |               +-Literal(type=DOUBLE, value=0)
    +-input_scan=
      +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
==

# Signature: fn_fp_ArrayT_T(ARRAY<T>, T, T->BOOL)
# In this test, INT64 and DOUBLE are provided for template type T and we don't
# cast ARRAY<INT64> to ARRAY<DOUBLE>.
# This test is here to show that the following two tests are consistent with
# current behaviour without lambda.
SELECT fn_fp_ArrayT_T([1, 2], 1.0);
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_FP_ARRAYT_T for argument types: ARRAY<INT64>, DOUBLE. Supported signature: FN_FP_ARRAYT_T(ARRAY, ANY) [at 1:8]
SELECT fn_fp_ArrayT_T([1, 2], 1.0);
       ^
==

SELECT fn_fp_ArrayT_T_LAMBDA([1, 2], 1, e->e>0);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#2 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#2]
    +-expr_list=
    | +-$col1#2 :=
    |   +-FunctionCall(sample_functions:fn_fp_ArrayT_T_LAMBDA(ARRAY<INT64>, INT64, LAMBDA(INT64->BOOL)) -> INT64)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=ARRAY<INT64>, value=[1, 2])
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=INT64, value=1)
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=[$lambda_arg.e#1]
    |           +-body=
    |             +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |               +-ColumnRef(type=INT64, column=$lambda_arg.e#1)
    |               +-Literal(type=INT64, value=0)
    +-input_scan=
      +-SingleRowScan
==

# See the comment of test of fn_fp_ArrayT_T.
SELECT fn_fp_ArrayT_T_LAMBDA([1, 2], 1.0, e->e>0);
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_FP_ARRAYT_T_LAMBDA for argument types: ARRAY<INT64>, DOUBLE, LAMBDA. Supported signature: FN_FP_ARRAYT_T_LAMBDA(ARRAY, ANY, LAMBDA(ANY->BOOL)) [at 1:8]
SELECT fn_fp_ArrayT_T_LAMBDA([1, 2], 1.0, e->e>0);
       ^
==

SELECT fn_fp_T_LAMBDA_RET_T(1, e->e+1);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#2 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#2]
    +-expr_list=
    | +-$col1#2 :=
    |   +-FunctionCall(sample_functions:fn_fp_T_LAMBDA_RET_T(INT64, LAMBDA(INT64->INT64)) -> INT64)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=INT64, value=1)
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=[$lambda_arg.e#1]
    |           +-body=
    |             +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |               +-ColumnRef(type=INT64, column=$lambda_arg.e#1)
    |               +-Literal(type=INT64, value=1)
    +-input_scan=
      +-SingleRowScan
==

SELECT fn_fp_T_LAMBDA_RET_T(1, e->"abc");
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_FP_T_LAMBDA_RET_T for argument types: INT64, LAMBDA. Supported signature: FN_FP_T_LAMBDA_RET_T(ANY, LAMBDA(ANY->ANY)) [at 1:8]
SELECT fn_fp_T_LAMBDA_RET_T(1, e->"abc");
       ^
==

# Signature: fn_fp_array_sort(ARRARY<T>, (T, T)->INT64) -> ARRARY<T>
SELECT fn_fp_array_sort([1,2,3], (e1, e2) -> e1 - e2);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-FunctionCall(sample_functions:fn_fp_array_sort(ARRAY<INT64>, LAMBDA((INT64, INT64)->INT64)) -> INT64)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=ARRAY<INT64>, value=[1, 2, 3])
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=$lambda_arg.[e1#1, e2#2]
    |           +-body=
    |             +-FunctionCall(ZetaSQL:$subtract(INT64, INT64) -> INT64)
    |               +-ColumnRef(type=INT64, column=$lambda_arg.e1#1)
    |               +-ColumnRef(type=INT64, column=$lambda_arg.e2#2)
    +-input_scan=
      +-SingleRowScan
==

# Signature: fn_fp_array_reduce(ARRAY<T1>, T2, LAMBDA((T2, T1)->T2)) -> T2
SELECT fn_fp_array_reduce([1,2,3], 0, (s, e) -> s + e);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-FunctionCall(sample_functions:fn_fp_array_reduce(ARRAY<INT64>, INT64, LAMBDA((INT64, INT64)->INT64)) -> INT64)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=ARRAY<INT64>, value=[1, 2, 3])
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=INT64, value=0)
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=$lambda_arg.[s#1, e#2]
    |           +-body=
    |             +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |               +-ColumnRef(type=INT64, column=$lambda_arg.s#1)
    |               +-ColumnRef(type=INT64, column=$lambda_arg.e#2)
    +-input_scan=
      +-SingleRowScan
==

SELECT fn_fp_named_then_lambda("123", (e) -> e);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#2 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#2]
    +-expr_list=
    | +-$col1#2 :=
    |   +-FunctionCall(sample_functions:fn_fp_named_then_lambda(STRING format_string, LAMBDA(INT64->INT64)) -> INT64)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=STRING, value="123")
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=[$lambda_arg.e#1]
    |           +-body=
    |             +-ColumnRef(type=INT64, column=$lambda_arg.e#1)
    +-input_scan=
      +-SingleRowScan
==

SELECT fn_fp_named_then_lambda(format_string => "123", (e) -> e);
--
ERROR: Call to function sample_functions:fn_fp_named_then_lambda must not specify positional arguments after named arguments; named arguments must be specified last in the argument list [at 1:32]
SELECT fn_fp_named_then_lambda(format_string => "123", (e) -> e);
                               ^
==

SELECT fn_fp_named_then_lambda((e) -> e, format_string => "123");
--
ERROR: Named argument format_string is invalid because this call to function sample_functions:fn_fp_named_then_lambda also includes a positional argument corresponding to the same name in the function signature [at 1:42]
SELECT fn_fp_named_then_lambda((e) -> e, format_string => "123");
                                         ^
==

SELECT fn_fp_lambda_then_named((e) -> e, "123");
--
QueryStmt
+-output_column_list=
| +-$query.$col1#2 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#2]
    +-expr_list=
    | +-$col1#2 :=
    |   +-FunctionCall(sample_functions:fn_fp_lambda_then_named(LAMBDA(INT64->INT64), STRING format_string) -> INT64)
    |     +-FunctionArgument
    |     | +-inline_lambda=
    |     |   +-InlineLambda
    |     |     +-argument_list=[$lambda_arg.e#1]
    |     |     +-body=
    |     |       +-ColumnRef(type=INT64, column=$lambda_arg.e#1)
    |     +-FunctionArgument
    |       +-expr=
    |         +-Literal(type=STRING, value="123")
    +-input_scan=
      +-SingleRowScan
==

SELECT fn_fp_lambda_then_named((e) -> e, format_string => "123");
--
QueryStmt
+-output_column_list=
| +-$query.$col1#2 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#2]
    +-expr_list=
    | +-$col1#2 :=
    |   +-FunctionCall(sample_functions:fn_fp_lambda_then_named(LAMBDA(INT64->INT64), STRING format_string) -> INT64)
    |     +-FunctionArgument
    |     | +-inline_lambda=
    |     |   +-InlineLambda
    |     |     +-argument_list=[$lambda_arg.e#1]
    |     |     +-body=
    |     |       +-ColumnRef(type=INT64, column=$lambda_arg.e#1)
    |     +-FunctionArgument
    |       +-expr=
    |         +-Literal(type=STRING, value="123")
    +-input_scan=
      +-SingleRowScan
==

SELECT fn_fp_lambda_then_repeated((e) -> e, 1, 2, 3);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#2 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#2]
    +-expr_list=
    | +-$col1#2 :=
    |   +-FunctionCall(sample_functions:fn_fp_lambda_then_repeated(LAMBDA(INT64->INT64), repeated(3) INT64) -> INT64)
    |     +-FunctionArgument
    |     | +-inline_lambda=
    |     |   +-InlineLambda
    |     |     +-argument_list=[$lambda_arg.e#1]
    |     |     +-body=
    |     |       +-ColumnRef(type=INT64, column=$lambda_arg.e#1)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=INT64, value=1)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=INT64, value=2)
    |     +-FunctionArgument
    |       +-expr=
    |         +-Literal(type=INT64, value=3)
    +-input_scan=
      +-SingleRowScan
==

# test that the signatures are properly printed.
SELECT fn_fp_repeated_arg_then_lambda(1, 2, 3, (e) -> e);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#2 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#2]
    +-expr_list=
    | +-$col1#2 :=
    |   +-FunctionCall(sample_functions:fn_fp_repeated_arg_then_lambda(repeated(3) INT64, LAMBDA(INT64->INT64)) -> INT64)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=INT64, value=1)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=INT64, value=2)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=INT64, value=3)
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=[$lambda_arg.e#1]
    |           +-body=
    |             +-ColumnRef(type=INT64, column=$lambda_arg.e#1)
    +-input_scan=
      +-SingleRowScan
==

SELECT fn_fp_repeated_arg_then_lambda((e) -> e);
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_FP_REPEATED_ARG_THEN_LAMBDA for argument types: LAMBDA. Supported signature: FN_FP_REPEATED_ARG_THEN_LAMBDA([INT64, ...], LAMBDA(INT64->ANY)) [at 1:8]
SELECT fn_fp_repeated_arg_then_lambda((e) -> e);
       ^
==

SELECT ARRAY_FILTER([1,2,3], e -> e>0);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#2 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#2]
    +-expr_list=
    | +-$col1#2 :=
    |   +-FunctionCall(ZetaSQL:array_filter(ARRAY<INT64>, LAMBDA(INT64->BOOL)) -> ARRAY<INT64>)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=ARRAY<INT64>, value=[1, 2, 3])
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=[$lambda_arg.e#1]
    |           +-body=
    |             +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |               +-ColumnRef(type=INT64, column=$lambda_arg.e#1)
    |               +-Literal(type=INT64, value=0)
    +-input_scan=
      +-SingleRowScan
==

SELECT ARRAY_FILTER([1,2,3], (e, i) -> e>i*i);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-FunctionCall(ZetaSQL:array_filter(ARRAY<INT64>, LAMBDA((INT64, INT64)->BOOL)) -> ARRAY<INT64>)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=ARRAY<INT64>, value=[1, 2, 3])
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=$lambda_arg.[e#1, i#2]
    |           +-body=
    |             +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |               +-ColumnRef(type=INT64, column=$lambda_arg.e#1)
    |               +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
    |                 +-ColumnRef(type=INT64, column=$lambda_arg.i#2)
    |                 +-ColumnRef(type=INT64, column=$lambda_arg.i#2)
    +-input_scan=
      +-SingleRowScan
==

SELECT ARRAY_TRANSFORM([1,2,3], (e) -> e+1);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#2 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#2]
    +-expr_list=
    | +-$col1#2 :=
    |   +-FunctionCall(ZetaSQL:array_transform(ARRAY<INT64>, LAMBDA(INT64->INT64)) -> ARRAY<INT64>)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=ARRAY<INT64>, value=[1, 2, 3])
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=[$lambda_arg.e#1]
    |           +-body=
    |             +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |               +-ColumnRef(type=INT64, column=$lambda_arg.e#1)
    |               +-Literal(type=INT64, value=1)
    +-input_scan=
      +-SingleRowScan
==

SELECT ARRAY_TRANSFORM([1,2,3], (e, i) -> i*100 + e);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-FunctionCall(ZetaSQL:array_transform(ARRAY<INT64>, LAMBDA((INT64, INT64)->INT64)) -> ARRAY<INT64>)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=ARRAY<INT64>, value=[1, 2, 3])
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=$lambda_arg.[e#1, i#2]
    |           +-body=
    |             +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |               +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
    |               | +-ColumnRef(type=INT64, column=$lambda_arg.i#2)
    |               | +-Literal(type=INT64, value=100)
    |               +-ColumnRef(type=INT64, column=$lambda_arg.e#1)
    +-input_scan=
      +-SingleRowScan
==

SELECT ARRAY_TRANSFORM([1,2,3], (e, i) -> i*100 + e);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-FunctionCall(ZetaSQL:array_transform(ARRAY<INT64>, LAMBDA((INT64, INT64)->INT64)) -> ARRAY<INT64>)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=ARRAY<INT64>, value=[1, 2, 3])
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=$lambda_arg.[e#1, i#2]
    |           +-body=
    |             +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |               +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
    |               | +-ColumnRef(type=INT64, column=$lambda_arg.i#2)
    |               | +-Literal(type=INT64, value=100)
    |               +-ColumnRef(type=INT64, column=$lambda_arg.e#1)
    +-input_scan=
      +-SingleRowScan
==

SELECT ARRAY_TRANSFORM([1,2,3], (e, i) -> CAST(i*100 + e AS STRING));
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-FunctionCall(ZetaSQL:array_transform(ARRAY<INT64>, LAMBDA((INT64, INT64)->STRING)) -> ARRAY<STRING>)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=ARRAY<INT64>, value=[1, 2, 3])
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=$lambda_arg.[e#1, i#2]
    |           +-body=
    |             +-Cast(INT64 -> STRING)
    |               +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |                 +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
    |                 | +-ColumnRef(type=INT64, column=$lambda_arg.i#2)
    |                 | +-Literal(type=INT64, value=100)
    |                 +-ColumnRef(type=INT64, column=$lambda_arg.e#1)
    +-input_scan=
      +-SingleRowScan
==

# Make sure undeclared query parameters resolve correctly inside the lambda
# body.
[allow_undeclared_parameters]
[enabled_ast_rewrites=DEFAULTS]
SELECT ARRAY_TRANSFORM([1,2,3], (e, i) -> CAST(i*@factor + e AS STRING));
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-FunctionCall(ZetaSQL:array_transform(ARRAY<INT64>, LAMBDA((INT64, INT64)->STRING)) -> ARRAY<STRING>)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=ARRAY<INT64>, value=[1, 2, 3])
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=$lambda_arg.[e#1, i#2]
    |           +-body=
    |             +-Cast(INT64 -> STRING)
    |               +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |                 +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
    |                 | +-ColumnRef(type=INT64, column=$lambda_arg.i#2)
    |                 | +-Parameter(parse_location=49-56, type=INT64, name="factor", is_untyped=TRUE)
    |                 +-ColumnRef(type=INT64, column=$lambda_arg.e#1)
    +-input_scan=
      +-SingleRowScan
[UNDECLARED_PARAMETERS]
factor: INT64

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-SubqueryExpr
    |     +-type=ARRAY<STRING>
    |     +-subquery_type=SCALAR
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.$col1#8]
    |         +-expr_list=
    |         | +-$col1#8 :=
    |         |   +-FunctionCall(ZetaSQL:if(BOOL, ARRAY<STRING>, ARRAY<STRING>) -> ARRAY<STRING>)
    |         |     +-FunctionCall(ZetaSQL:$is_null(ARRAY<INT64>) -> BOOL)
    |         |     | +-ColumnRef(type=ARRAY<INT64>, column=$subquery1.array_input#4)
    |         |     +-Literal(type=ARRAY<STRING>, value=NULL)
    |         |     +-SubqueryExpr
    |         |       +-type=ARRAY<STRING>
    |         |       +-subquery_type=ARRAY
    |         |       +-parameter_list=
    |         |       | +-ColumnRef(type=ARRAY<INT64>, column=$subquery1.array_input#4)
    |         |       +-subquery=
    |         |         +-OrderByScan
    |         |           +-column_list=[$expr_subquery.$col1#7]
    |         |           +-is_ordered=TRUE
    |         |           +-input_scan=
    |         |           | +-ProjectScan
    |         |           |   +-column_list=[$array.element#5, $array_offset.off#6, $expr_subquery.$col1#7]
    |         |           |   +-expr_list=
    |         |           |   | +-$col1#7 :=
    |         |           |   |   +-Cast(INT64 -> STRING)
    |         |           |   |     +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |         |           |   |       +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
    |         |           |   |       | +-ColumnRef(type=INT64, column=$array_offset.off#6)
    |         |           |   |       | +-Parameter(parse_location=49-56, type=INT64, name="factor", is_untyped=TRUE)
    |         |           |   |       +-ColumnRef(type=INT64, column=$array.element#5)
    |         |           |   +-input_scan=
    |         |           |     +-ArrayScan
    |         |           |       +-column_list=[$array.element#5, $array_offset.off#6]
    |         |           |       +-array_expr=
    |         |           |       | +-ColumnRef(type=ARRAY<INT64>, column=$subquery1.array_input#4, is_correlated=TRUE)
    |         |           |       +-element_column=$array.element#5
    |         |           |       +-array_offset_column=
    |         |           |         +-ColumnHolder(column=$array_offset.off#6)
    |         |           +-order_by_item_list=
    |         |             +-OrderByItem
    |         |               +-column_ref=
    |         |                 +-ColumnRef(type=INT64, column=$array_offset.off#6)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=[$subquery1.array_input#4]
    |             +-expr_list=
    |             | +-array_input#4 := Literal(type=ARRAY<INT64>, value=[1, 2, 3])
    |             +-input_scan=
    |               +-SingleRowScan
    +-input_scan=
      +-SingleRowScan
==

# Similar to the previous, but choosing a parameter name that potentially
# conflicts with a parameter of the substitution template.
[allow_undeclared_parameters]
[enabled_ast_rewrites=DEFAULTS]
SELECT ARRAY_TRANSFORM([1,2,3], (e, i) -> CAST(i*@array_input + e AS STRING));
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-FunctionCall(ZetaSQL:array_transform(ARRAY<INT64>, LAMBDA((INT64, INT64)->STRING)) -> ARRAY<STRING>)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=ARRAY<INT64>, value=[1, 2, 3])
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=$lambda_arg.[e#1, i#2]
    |           +-body=
    |             +-Cast(INT64 -> STRING)
    |               +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |                 +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
    |                 | +-ColumnRef(type=INT64, column=$lambda_arg.i#2)
    |                 | +-Parameter(parse_location=49-61, type=INT64, name="array_input", is_untyped=TRUE)
    |                 +-ColumnRef(type=INT64, column=$lambda_arg.e#1)
    +-input_scan=
      +-SingleRowScan
[UNDECLARED_PARAMETERS]
array_input: INT64

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-SubqueryExpr
    |     +-type=ARRAY<STRING>
    |     +-subquery_type=SCALAR
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.$col1#8]
    |         +-expr_list=
    |         | +-$col1#8 :=
    |         |   +-FunctionCall(ZetaSQL:if(BOOL, ARRAY<STRING>, ARRAY<STRING>) -> ARRAY<STRING>)
    |         |     +-FunctionCall(ZetaSQL:$is_null(ARRAY<INT64>) -> BOOL)
    |         |     | +-ColumnRef(type=ARRAY<INT64>, column=$subquery1.array_input#4)
    |         |     +-Literal(type=ARRAY<STRING>, value=NULL)
    |         |     +-SubqueryExpr
    |         |       +-type=ARRAY<STRING>
    |         |       +-subquery_type=ARRAY
    |         |       +-parameter_list=
    |         |       | +-ColumnRef(type=ARRAY<INT64>, column=$subquery1.array_input#4)
    |         |       +-subquery=
    |         |         +-OrderByScan
    |         |           +-column_list=[$expr_subquery.$col1#7]
    |         |           +-is_ordered=TRUE
    |         |           +-input_scan=
    |         |           | +-ProjectScan
    |         |           |   +-column_list=[$array.element#5, $array_offset.off#6, $expr_subquery.$col1#7]
    |         |           |   +-expr_list=
    |         |           |   | +-$col1#7 :=
    |         |           |   |   +-Cast(INT64 -> STRING)
    |         |           |   |     +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |         |           |   |       +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
    |         |           |   |       | +-ColumnRef(type=INT64, column=$array_offset.off#6)
    |         |           |   |       | +-Parameter(parse_location=49-61, type=INT64, name="array_input", is_untyped=TRUE)
    |         |           |   |       +-ColumnRef(type=INT64, column=$array.element#5)
    |         |           |   +-input_scan=
    |         |           |     +-ArrayScan
    |         |           |       +-column_list=[$array.element#5, $array_offset.off#6]
    |         |           |       +-array_expr=
    |         |           |       | +-ColumnRef(type=ARRAY<INT64>, column=$subquery1.array_input#4, is_correlated=TRUE)
    |         |           |       +-element_column=$array.element#5
    |         |           |       +-array_offset_column=
    |         |           |         +-ColumnHolder(column=$array_offset.off#6)
    |         |           +-order_by_item_list=
    |         |             +-OrderByItem
    |         |               +-column_ref=
    |         |                 +-ColumnRef(type=INT64, column=$array_offset.off#6)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=[$subquery1.array_input#4]
    |             +-expr_list=
    |             | +-array_input#4 := Literal(type=ARRAY<INT64>, value=[1, 2, 3])
    |             +-input_scan=
    |               +-SingleRowScan
    +-input_scan=
      +-SingleRowScan
==

# Make sure positional query parameters resolve correctly inside the lambda
# body.
[allow_undeclared_parameters]
[parameter_mode=positional]
[enabled_ast_rewrites=DEFAULTS]
SELECT ARRAY_TRANSFORM([1,2,3], (e, i) -> CAST(i*? + e AS STRING));
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-FunctionCall(ZetaSQL:array_transform(ARRAY<INT64>, LAMBDA((INT64, INT64)->STRING)) -> ARRAY<STRING>)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=ARRAY<INT64>, value=[1, 2, 3])
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=$lambda_arg.[e#1, i#2]
    |           +-body=
    |             +-Cast(INT64 -> STRING)
    |               +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |                 +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
    |                 | +-ColumnRef(type=INT64, column=$lambda_arg.i#2)
    |                 | +-Parameter(parse_location=49-50, type=INT64, position=1, is_untyped=TRUE)
    |                 +-ColumnRef(type=INT64, column=$lambda_arg.e#1)
    +-input_scan=
      +-SingleRowScan
[UNDECLARED_PARAMETERS]
INT64

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-SubqueryExpr
    |     +-type=ARRAY<STRING>
    |     +-subquery_type=SCALAR
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.$col1#8]
    |         +-expr_list=
    |         | +-$col1#8 :=
    |         |   +-FunctionCall(ZetaSQL:if(BOOL, ARRAY<STRING>, ARRAY<STRING>) -> ARRAY<STRING>)
    |         |     +-FunctionCall(ZetaSQL:$is_null(ARRAY<INT64>) -> BOOL)
    |         |     | +-ColumnRef(type=ARRAY<INT64>, column=$subquery1.array_input#4)
    |         |     +-Literal(type=ARRAY<STRING>, value=NULL)
    |         |     +-SubqueryExpr
    |         |       +-type=ARRAY<STRING>
    |         |       +-subquery_type=ARRAY
    |         |       +-parameter_list=
    |         |       | +-ColumnRef(type=ARRAY<INT64>, column=$subquery1.array_input#4)
    |         |       +-subquery=
    |         |         +-OrderByScan
    |         |           +-column_list=[$expr_subquery.$col1#7]
    |         |           +-is_ordered=TRUE
    |         |           +-input_scan=
    |         |           | +-ProjectScan
    |         |           |   +-column_list=[$array.element#5, $array_offset.off#6, $expr_subquery.$col1#7]
    |         |           |   +-expr_list=
    |         |           |   | +-$col1#7 :=
    |         |           |   |   +-Cast(INT64 -> STRING)
    |         |           |   |     +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |         |           |   |       +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
    |         |           |   |       | +-ColumnRef(type=INT64, column=$array_offset.off#6)
    |         |           |   |       | +-Parameter(parse_location=49-50, type=INT64, position=1, is_untyped=TRUE)
    |         |           |   |       +-ColumnRef(type=INT64, column=$array.element#5)
    |         |           |   +-input_scan=
    |         |           |     +-ArrayScan
    |         |           |       +-column_list=[$array.element#5, $array_offset.off#6]
    |         |           |       +-array_expr=
    |         |           |       | +-ColumnRef(type=ARRAY<INT64>, column=$subquery1.array_input#4, is_correlated=TRUE)
    |         |           |       +-element_column=$array.element#5
    |         |           |       +-array_offset_column=
    |         |           |         +-ColumnHolder(column=$array_offset.off#6)
    |         |           +-order_by_item_list=
    |         |             +-OrderByItem
    |         |               +-column_ref=
    |         |                 +-ColumnRef(type=INT64, column=$array_offset.off#6)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=[$subquery1.array_input#4]
    |             +-expr_list=
    |             | +-array_input#4 := Literal(type=ARRAY<INT64>, value=[1, 2, 3])
    |             +-input_scan=
    |               +-SingleRowScan
    +-input_scan=
      +-SingleRowScan
