# Analyzer tests for ZetaSQL named arguments as designed at
# (broken link).
#
# Valid function call with named arguments in the same order as they appear in
# the function signature.
# TODO: Enable Java support. The functionality is not provided for
# analyzing TVF calls with Java support currently, when this is added, both the
# function_default_argument.test, tvf_relation_args.test file and this file can
# be updated at the same time.
[default no_java]
[default language_features=NAMED_ARGUMENTS,TABLE_VALUED_FUNCTIONS]
select fn_named_args(format_string => "%x", date_string => "12/25/08")
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_named_args(STRING format_string, STRING date_string) -> BOOL)
    |     +-Literal(type=STRING, value="%x")
    |     +-Literal(type=STRING, value="12/25/08")
    +-input_scan=
      +-SingleRowScan
==

# Valid function call with named arguments in a different order that they appear
# in the function signature.
select fn_named_args(date_string => "12/25/08", format_string => "%x")
--
[SAME AS PREVIOUS]
==

# Valid function call with named arguments assigned to non-literal expressions.
select fn_named_args(
    format_string => concat("%", "x"),
    date_string => concat(cast(10 + 2 as string), "/25/08"))
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_named_args(STRING format_string, STRING date_string) -> BOOL)
    |     +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
    |     | +-Literal(type=STRING, value="%")
    |     | +-Literal(type=STRING, value="x")
    |     +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
    |       +-Cast(INT64 -> STRING)
    |       | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |       |   +-Literal(type=INT64, value=10)
    |       |   +-Literal(type=INT64, value=2)
    |       +-Literal(type=STRING, value="/25/08")
    +-input_scan=
      +-SingleRowScan
==

# Valid function call with a positional argument followed by a named argument.
# For this example, the function signature comprises two named arguments like
# this: create function fn_named_args(format_string STRING, date_string STRING);
# Calls to this function may provide the arguments positionally (following the
# order in the function signature) or by name, or a combination of the former
# followed by the latter.
select fn_named_args("%x", date_string => "12/25/08")
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_named_args(STRING format_string, STRING date_string) -> BOOL)
    |     +-Literal(type=STRING, value="%x")
    |     +-Literal(type=STRING, value="12/25/08")
    +-input_scan=
      +-SingleRowScan
==

# Valid function call with named arguments for a function that has two
# signatures.
select fn_named_args_two_signatures(
    format_string => "%X", date_string => "12/25/08");
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_named_args_two_signatures(STRING format_string, STRING date_string) -> BOOL)
    |     +-Literal(type=STRING, value="%X")
    |     +-Literal(type=STRING, value="12/25/08")
    +-input_scan=
      +-SingleRowScan
==

# Valid function call with two required arguments and one named argument.
select fn_three_named_args_two_signatures(
    "%X", "12/25/08",  format_string => "%X");
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_three_named_args_two_signatures(STRING, STRING, STRING format_string) -> BOOL)
    |     +-Literal(type=STRING, value="%X")
    |     +-Literal(type=STRING, value="12/25/08")
    |     +-Literal(type=STRING, value="%X")
    +-input_scan=
      +-SingleRowScan
==

# Valid function call with two required arguments and one named argument.
select fn_three_named_args_two_signatures(
    "%X", "12/25/08",  date_string => "12/25/08");
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_three_named_args_two_signatures(STRING, STRING, STRING date_string) -> BOOL)
    |     +-Literal(type=STRING, value="%X")
    |     +-Literal(type=STRING, value="12/25/08")
    |     +-Literal(type=STRING, value="12/25/08")
    +-input_scan=
      +-SingleRowScan
==

# Invalid function call with two required arguments and one named argument,
# because the provided argument name is wrong.
select fn_three_named_args_two_signatures(
    "%X", "12/25/08",  invalid_arg_name => "12/25/08");
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_THREE_NAMED_ARGS_TWO_SIGNATURES for argument types: STRING, STRING, STRING. Supported signatures: FN_THREE_NAMED_ARGS_TWO_SIGNATURES(STRING, STRING, STRING); FN_THREE_NAMED_ARGS_TWO_SIGNATURES(STRING, STRING, STRING) [at 1:8]
select fn_three_named_args_two_signatures(
       ^
==

# Invalid function call with two required arguments and one named argument.
# The second required non-named argument is missing.
select fn_three_named_args_two_signatures(
    "%X", format_string => "%X");
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_THREE_NAMED_ARGS_TWO_SIGNATURES for argument types: STRING, STRING. Supported signatures: FN_THREE_NAMED_ARGS_TWO_SIGNATURES(STRING, STRING, STRING); FN_THREE_NAMED_ARGS_TWO_SIGNATURES(STRING, STRING, STRING) [at 1:8]
select fn_three_named_args_two_signatures(
       ^
==

# Valid function call with named arguments for a function with optional
# arguments.
select fn_named_args_optional(
    format_string => "%X", date_string => "12/25/08");
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_named_args_optional(optional(1) STRING format_string, optional(1) STRING date_string) -> BOOL)
    |     +-Literal(type=STRING, value="%X")
    |     +-Literal(type=STRING, value="12/25/08")
    +-input_scan=
      +-SingleRowScan
==

# Valid function call with named arguments for a function with optional
# arguments with some optional arguments not named.
select fn_named_args_optional(format_string => "%X")
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_named_args_optional(optional(1) STRING format_string, optional(1) STRING date_string) -> BOOL)
    |     +-Literal(type=STRING, value="%X")
    |     +-Literal(type=STRING, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

# Valid function call with named arguments for a function with optional
# arguments with some optional arguments not named.
select fn_named_args_optional(date_string => "12/25/08")
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_named_args_optional(optional(1) STRING format_string, optional(1) STRING date_string) -> BOOL)
    |     +-Literal(type=STRING, value=NULL)
    |     +-Literal(type=STRING, value="12/25/08")
    +-input_scan=
      +-SingleRowScan
==

# Valid TVF call with two scalar named arguments.
select * from tvf_named_required_scalar_args(
    date_string => "12/25/08", format_string => "%X")
--
QueryStmt
+-output_column_list=
| +-tvf_named_required_scalar_args.column_bool#1 AS column_bool [BOOL]
| +-tvf_named_required_scalar_args.column_bytes#2 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_named_required_scalar_args.[column_bool#1, column_bytes#2]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_named_required_scalar_args.[column_bool#1, column_bytes#2]
        +-tvf=tvf_named_required_scalar_args((STRING format_string, STRING date_string) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(literal STRING, literal STRING) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=STRING, value="%X")
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=STRING, value="12/25/08")
        +-column_index_list=[0, 1]
==

# Valid TVF call with two scalar optional named arguments.
select * from tvf_named_optional_scalar_args(
    format_string => "%X", date_string => "12/25/08")
--
QueryStmt
+-output_column_list=
| +-tvf_named_optional_scalar_args.column_bool#1 AS column_bool [BOOL]
| +-tvf_named_optional_scalar_args.column_bytes#2 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_named_optional_scalar_args.[column_bool#1, column_bytes#2]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_named_optional_scalar_args.[column_bool#1, column_bytes#2]
        +-tvf=tvf_named_optional_scalar_args((optional STRING format_string, optional STRING date_string) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(literal STRING, literal STRING) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=STRING, value="%X")
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=STRING, value="12/25/08")
        +-column_index_list=[0, 1]
==

# Valid TVF call with named arguments for a function with optional arguments
# with some optional arguments not named.
select * from tvf_named_optional_scalar_args(format_string => "%X")
--
QueryStmt
+-output_column_list=
| +-tvf_named_optional_scalar_args.column_bool#1 AS column_bool [BOOL]
| +-tvf_named_optional_scalar_args.column_bytes#2 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_named_optional_scalar_args.[column_bool#1, column_bytes#2]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_named_optional_scalar_args.[column_bool#1, column_bytes#2]
        +-tvf=tvf_named_optional_scalar_args((optional STRING format_string, optional STRING date_string) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(literal STRING, null STRING) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=STRING, value="%X")
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=STRING, value=NULL)
        +-column_index_list=[0, 1]
==

# Valid TVF call with named arguments for a function with optional arguments
# with some optional arguments not named.
select * from tvf_named_optional_scalar_args(date_string => "12/25/08")
--
QueryStmt
+-output_column_list=
| +-tvf_named_optional_scalar_args.column_bool#1 AS column_bool [BOOL]
| +-tvf_named_optional_scalar_args.column_bytes#2 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_named_optional_scalar_args.[column_bool#1, column_bytes#2]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_named_optional_scalar_args.[column_bool#1, column_bytes#2]
        +-tvf=tvf_named_optional_scalar_args((optional STRING format_string, optional STRING date_string) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(null STRING, literal STRING) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=STRING, value=NULL)
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=STRING, value="12/25/08")
        +-column_index_list=[0, 1]
==

# Valid TVF call with a named argument for a function with an optional relation
# argument.
select * from tvf_named_optional_any_relation_arg(
    any_relation_arg => (select 1 as x))
--
QueryStmt
+-output_column_list=
| +-tvf_named_optional_any_relation_arg.column_bool#2 AS column_bool [BOOL]
| +-tvf_named_optional_any_relation_arg.column_bytes#3 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_named_optional_any_relation_arg.[column_bool#2, column_bytes#3]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_named_optional_any_relation_arg.[column_bool#2, column_bytes#3]
        +-tvf=tvf_named_optional_any_relation_arg((optional ANY TABLE any_relation_arg) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<x INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery1.x#1]
        |   |   +-expr_list=
        |   |   | +-x#1 := Literal(type=INT64, value=1)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=[$subquery1.x#1]
        +-column_index_list=[0, 1]
==

# Invalid TVF call with a named argument for a function with an optional
# relation argument using the wrong name.
select * from tvf_named_optional_any_relation_arg(
    invalid_arg => (select 1 as x))
--
ERROR: Named argument invalid_arg not found in signature for call to function tvf_named_optional_any_relation_arg [at 2:5]
    invalid_arg => (select 1 as x))
    ^
==

# Valid TVF call with named arguments for a function with an optional relation
# argument and an optional scalar argument.
# The TVF signature looks like:
#   tvf_named_optional_any_relation_arg_optional_scalar_arg(
#       optional any_relation_arg ANY TABLE,
#       optional format_string STRING)
#     RETURNS TABLE<BOOL, BYTES>.
select * from tvf_named_optional_any_relation_arg_optional_scalar_arg(
    format_string => 'abc', any_relation_arg => (select 1 as x))
--
QueryStmt
+-output_column_list=
| +-tvf_named_optional_any_relation_arg_optional_scalar_arg.column_bool#2 AS column_bool [BOOL]
| +-tvf_named_optional_any_relation_arg_optional_scalar_arg.column_bytes#3 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_named_optional_any_relation_arg_optional_scalar_arg.[column_bool#2, column_bytes#3]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_named_optional_any_relation_arg_optional_scalar_arg.[column_bool#2, column_bytes#3]
        +-tvf=tvf_named_optional_any_relation_arg_optional_scalar_arg((optional ANY TABLE any_relation_arg, optional STRING format_string) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<x INT64>, literal STRING) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=[$subquery1.x#1]
        | | |   +-expr_list=
        | | |   | +-x#1 := Literal(type=INT64, value=1)
        | | |   +-input_scan=
        | | |     +-SingleRowScan
        | | +-argument_column_list=[$subquery1.x#1]
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=STRING, value="abc")
        +-column_index_list=[0, 1]
==

# Invalid TVF call with the STRING named argument provided but the relation
# argument omitted.
# The TVF signature is the same as above.
# TODO: Allow the optional 'any_relation_arg' to be omitted. This
# is implmented by not materizling omitted arguments that do not have default
# values in the resolved function or TVF nodes at all.
select * from tvf_named_optional_any_relation_arg_optional_scalar_arg(
    format_string => 'abc')
--
ERROR: No matching signature for tvf_named_optional_any_relation_arg_optional_scalar_arg for argument types: NULL, STRING. Supported signature: TVF_NAMED_OPTIONAL_ANY_RELATION_ARG_OPTIONAL_SCALAR_ARG([TABLE], [STRING]) [at 1:15]
select * from tvf_named_optional_any_relation_arg_optional_scalar_arg(
              ^
==

# Valid TVF call with the relation named argument provided and the STRING
# argument omitted.
# The TVF signature is the same as above.
# TODO: Update this test case to remove the injected NULL argument
# for the omitted 'format_string' argument once we have the feature not to
# materializing omitted arguments without default values in the resolved
# function call node.
select * from tvf_named_optional_any_relation_arg_optional_scalar_arg(
    any_relation_arg => (select 1 as x))
--
QueryStmt
+-output_column_list=
| +-tvf_named_optional_any_relation_arg_optional_scalar_arg.column_bool#2 AS column_bool [BOOL]
| +-tvf_named_optional_any_relation_arg_optional_scalar_arg.column_bytes#3 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_named_optional_any_relation_arg_optional_scalar_arg.[column_bool#2, column_bytes#3]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_named_optional_any_relation_arg_optional_scalar_arg.[column_bool#2, column_bytes#3]
        +-tvf=tvf_named_optional_any_relation_arg_optional_scalar_arg((optional ANY TABLE any_relation_arg, optional STRING format_string) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<x INT64>, null STRING) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=[$subquery1.x#1]
        | | |   +-expr_list=
        | | |   | +-x#1 := Literal(type=INT64, value=1)
        | | |   +-input_scan=
        | | |     +-SingleRowScan
        | | +-argument_column_list=[$subquery1.x#1]
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=STRING, value=NULL)
        +-column_index_list=[0, 1]
==

# Valid TVF call with one "any table" relation named argument.
select * from tvf_named_required_any_relation_arg(
    any_relation_arg => (select * from keyvalue))
--
QueryStmt
+-output_column_list=
| +-tvf_named_required_any_relation_arg.column_bool#3 AS column_bool [BOOL]
| +-tvf_named_required_any_relation_arg.column_bytes#4 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_named_required_any_relation_arg.[column_bool#3, column_bytes#4]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_named_required_any_relation_arg.[column_bool#3, column_bytes#4]
        +-tvf=tvf_named_required_any_relation_arg((ANY TABLE any_relation_arg) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<Key INT64, Value STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=KeyValue.[Key#1, Value#2]
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |   +-argument_column_list=KeyValue.[Key#1, Value#2]
        +-column_index_list=[0, 1]
==

# Valid TVF call with one relation named argument with required schema.
select * from tvf_named_required_schema_relation_arg(
    schema_relation_arg => (select true as column_bool,
                            cast("abc" as bytes) as column_bytes))
--
QueryStmt
+-output_column_list=
| +-tvf_named_required_schema_relation_arg.column_bool#3 AS column_bool [BOOL]
| +-tvf_named_required_schema_relation_arg.column_bytes#4 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_named_required_schema_relation_arg.[column_bool#3, column_bytes#4]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_named_required_schema_relation_arg.[column_bool#3, column_bytes#4]
        +-tvf=tvf_named_required_schema_relation_arg((TABLE<column_bool BOOL, column_bytes BYTES> schema_relation_arg) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<column_bool BOOL, column_bytes BYTES>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$subquery1.[column_bool#1, column_bytes#2]
        |   |   +-expr_list=
        |   |   | +-column_bool#1 := Literal(type=BOOL, value=true)
        |   |   | +-column_bytes#2 := Literal(type=BYTES, value=b"abc", has_explicit_type=TRUE)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=$subquery1.[column_bool#1, column_bytes#2]
        +-column_index_list=[0, 1]
==

# Valid TVF call with one relation named argument with a value table.
select * from tvf_named_required_value_table_relation_arg(
    value_table_relation_arg => (select as value cast (null as zetasql_test__.TestExtraPB) from keyvalue))
--
QueryStmt
+-output_column_list=
| +-tvf_named_required_value_table_relation_arg.column_bool#4 AS column_bool [BOOL]
| +-tvf_named_required_value_table_relation_arg.column_bytes#5 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_named_required_value_table_relation_arg.[column_bool#4, column_bytes#5]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_named_required_value_table_relation_arg.[column_bool#4, column_bytes#5]
        +-tvf=tvf_named_required_value_table_relation_arg((TABLE<PROTO<zetasql_test__.TestExtraPB>> value_table_relation_arg) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<PROTO<zetasql_test__.TestExtraPB>>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery1.$col1#3]
        |   |   +-expr_list=
        |   |   | +-$col1#3 := Literal(type=PROTO<zetasql_test__.TestExtraPB>, value=NULL, has_explicit_type=TRUE)
        |   |   +-input_scan=
        |   |     +-TableScan(table=KeyValue)
        |   +-argument_column_list=[$subquery1.$col1#3]
        +-column_index_list=[0, 1]
==

# Valid TVF call with a combination of named scalar and relation arguments.
select * from tvf_named_scalar_and_relation_args(
    format_string => "%X",
    schema_relation_arg => (select true as column_bool,
                            cast("abc" as bytes) as column_bytes))
--
QueryStmt
+-output_column_list=
| +-tvf_named_scalar_and_relation_args.column_bool#3 AS column_bool [BOOL]
| +-tvf_named_scalar_and_relation_args.column_bytes#4 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_named_scalar_and_relation_args.[column_bool#3, column_bytes#4]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_named_scalar_and_relation_args.[column_bool#3, column_bytes#4]
        +-tvf=tvf_named_scalar_and_relation_args((STRING format_string, TABLE<column_bool BOOL, column_bytes BYTES> schema_relation_arg) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(literal STRING, TABLE<column_bool BOOL, column_bytes BYTES>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=STRING, value="%X")
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$subquery1.[column_bool#1, column_bytes#2]
        |   |   +-expr_list=
        |   |   | +-column_bool#1 := Literal(type=BOOL, value=true)
        |   |   | +-column_bytes#2 := Literal(type=BYTES, value=b"abc", has_explicit_type=TRUE)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=$subquery1.[column_bool#1, column_bytes#2]
        +-column_index_list=[0, 1]
==

# Valid TVF call with a combination of named and positional arguments.
select * from tvf_named_scalar_and_relation_args(
    "%X",
    schema_relation_arg => (select true as column_bool,
                            cast("abc" as bytes) as column_bytes))
--
QueryStmt
+-output_column_list=
| +-tvf_named_scalar_and_relation_args.column_bool#3 AS column_bool [BOOL]
| +-tvf_named_scalar_and_relation_args.column_bytes#4 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_named_scalar_and_relation_args.[column_bool#3, column_bytes#4]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_named_scalar_and_relation_args.[column_bool#3, column_bytes#4]
        +-tvf=tvf_named_scalar_and_relation_args((STRING format_string, TABLE<column_bool BOOL, column_bytes BYTES> schema_relation_arg) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(literal STRING, TABLE<column_bool BOOL, column_bytes BYTES>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=STRING, value="%X")
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$subquery1.[column_bool#1, column_bytes#2]
        |   |   +-expr_list=
        |   |   | +-column_bool#1 := Literal(type=BOOL, value=true)
        |   |   | +-column_bytes#2 := Literal(type=BYTES, value=b"abc", has_explicit_type=TRUE)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=$subquery1.[column_bool#1, column_bytes#2]
        +-column_index_list=[0, 1]
==

# Invalid function call with named arguments. The resolver returns an error if
# these arguments are used positionally, and this is the case here.
select fn_named_args_error_if_positional(
    "%X",
    date_string => "12/25/08");
--
ERROR: Positional argument is invalid because this function restricts that this argument is referred to by name "format_string" only [at 2:5]
    "%X",
    ^
==

# Invalid function call with named arguments. The function call includes a
# positional argument after a named argument, which is invalid and returns an
# error. The latter function argument also includes an option which specifies
# that it may not be used positionally in general, but the function resolver
# does not reach far enough to check this case.
select fn_named_args_error_if_positional(
    format_string => "%X",
    "12/25/08");
--
ERROR: Call to function sample_functions:fn_named_args_error_if_positional must not specify positional arguments after named arguments; named arguments must be specified last in the argument list [at 2:5]
    format_string => "%X",
    ^
==

# Invalid function call with named arguments. The resolver returns an error if
# these arguments are used positionally, and this is the case here.
select fn_named_args_error_if_positional(
    "%X", "12/25/08");
--
ERROR: Positional argument is invalid because this function restricts that this argument is referred to by name "format_string" only [at 2:5]
    "%X", "12/25/08");
    ^
==

# Invalid function call with named arguments. The resolver returns an error if
# these arguments are used positionally, and this is the case here.
select fn_named_args_error_if_positional(
   "12/25/08",
   format_string=> "%X");
--
ERROR: Named argument format_string is invalid because this call to function sample_functions:fn_named_args_error_if_positional also includes a positional argument corresponding to the same name in the function signature [at 3:4]
   format_string=> "%X");
   ^
==

# Invalid function call with named arguments. The resolver returns an error if
# the first argument is used positionally, and this is the case here.
select fn_named_args_error_if_positional_first_arg(
    "%X",
    date_string => "12/25/08");
--
ERROR: Positional argument is invalid because this function restricts that this argument is referred to by name "format_string" only [at 2:5]
    "%X",
    ^
==

# Invalid function call with named arguments. The resolver returns an error if
# the first argument is used positionally, and this is the case here.
select fn_named_args_error_if_positional_second_arg(
    "%X",
    "12/25/08");
--
ERROR: Positional argument is invalid because this function restricts that this argument is referred to by name "date_string" only [at 3:5]
    "12/25/08");
    ^
==

# Invalid function call with mandatory-named arguments. The error includes
# the correct syntax for using named arguments.
select fn_named_args_error_if_positional(
    format_string => 1,
    date_string => "12/25/08");
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_NAMED_ARGS_ERROR_IF_POSITIONAL for argument types: INT64, STRING. Supported signature: FN_NAMED_ARGS_ERROR_IF_POSITIONAL(format_string => STRING, date_string => STRING) [at 1:8]
select fn_named_args_error_if_positional(
       ^
==

# Invalid function call with mandatory-named arguments, second of which is
# optional. The error includes the correct syntax for using named arguments.
select fn_named_optional_args_error_if_positional(
    format_string => 1,
    date_string => "12/25/08");
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_NAMED_OPTIONAL_ARGS_ERROR_IF_POSITIONAL for argument types: INT64, STRING. Supported signature: FN_NAMED_OPTIONAL_ARGS_ERROR_IF_POSITIONAL(format_string => STRING, [date_string => STRING]) [at 1:8]
select fn_named_optional_args_error_if_positional(
       ^
==

# Valid function call of a function that requires named required arguments.
select fn_named_args_error_if_positional(
    format_string => "%X",
    date_string => "12/25/08");
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_named_args_error_if_positional(STRING format_string, STRING date_string) -> BOOL)
    |     +-Literal(type=STRING, value="%X")
    |     +-Literal(type=STRING, value="12/25/08")
    +-input_scan=
      +-SingleRowScan
==

# Valid function call of a function that requires named arguments, one required
# and one optional.
select fn_named_optional_args_error_if_positional(
    format_string => "%X",
    date_string => "12/25/08");
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_named_optional_args_error_if_positional(STRING format_string, optional(1) STRING date_string) -> BOOL)
    |     +-Literal(type=STRING, value="%X")
    |     +-Literal(type=STRING, value="12/25/08")
    +-input_scan=
      +-SingleRowScan
==

# Valid function call of a function that requires named arguments, using
# argument order opposite to the function's signature order.
select fn_named_args_error_if_positional_second_arg(
    date_string => "12/25/08",
    format_string => "%X");
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_named_args_error_if_positional_second_arg(STRING format_string, STRING date_string) -> BOOL)
    |     +-Literal(type=STRING, value="%X")
    |     +-Literal(type=STRING, value="12/25/08")
    +-input_scan=
      +-SingleRowScan
==

# Valid function call of a function with two optional arguments, first regular
# one and second one named that cannot be specified positionally.
# In this call we omit the named argument.
select fn_optional_named_optional_args("foo")
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_optional_named_optional_args(optional(1) STRING, optional(1) STRING date_string) -> BOOL)
    |     +-Literal(type=STRING, value="foo")
    |     +-Literal(type=STRING, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

# Valid function call of a function with three optional arguments: regular one,
# named that cannot be specified positionally and cannot be null, and named that
# cannot be specified positionally.
# In this invocation we omit all named arguments.
# This currently fails, as mandatory-named argument substitution makes
# the omitted named arguments NULL.
select fn_optional_named_optional_not_null_args(arg => "foo")
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_optional_named_optional_not_null_args(optional(1) STRING, optional(1) STRING arg, optional(1) STRING date_string) -> BOOL)
    |     +-Literal(type=STRING, value=NULL)
    |     +-Literal(type=STRING, value="foo")
    |     +-Literal(type=STRING, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

# Invalid function call of a function with three optional arguments: regular
# one, named that cannot be specified positionally and cannot be null, and
# named that cannot be specified positionally.
# In this invocation we omit all named arguments.
# This currently fails, as mandatory-named argument substitution makes
# the omitted named arguments NULL.
select fn_optional_named_optional_not_null_args("foo")
--
ERROR: Argument 2 to SAMPLE_FUNCTIONS:FN_OPTIONAL_NAMED_OPTIONAL_NOT_NULL_ARGS must be non-NULL [at 1:8]
select fn_optional_named_optional_not_null_args("foo")
       ^
==

# Invalid function call of a function with three optional arguments: regular
# one, named that cannot be specified positionally and cannot be null, and
# named that cannot be specified positionally.
# In this invocation we omit first named argument, that cannot be NULL.
# This currently fails, as mandatory-named argument substitution makes
# the omitted named arguments NULL.
select fn_optional_named_optional_not_null_args("foo", date_string => "bar")
--
ERROR: Argument 2 to SAMPLE_FUNCTIONS:FN_OPTIONAL_NAMED_OPTIONAL_NOT_NULL_ARGS must be non-NULL [at 1:8]
select fn_optional_named_optional_not_null_args("foo", date_string => "bar")
       ^
==

# Invalid function call of a function with three optional arguments: regular one,
# named that cannot be specified positionally and cannot be null, and
# named cannot be specified positionally.
# In this call we pass NULL to first named argument, that cannot be NULL.
select fn_optional_named_optional_not_null_args("foo", arg => NULL, date_string => "bar")
--
ERROR: Argument 'arg' to SAMPLE_FUNCTIONS:FN_OPTIONAL_NAMED_OPTIONAL_NOT_NULL_ARGS must be non-NULL [at 1:56]
...fn_optional_named_optional_not_null_args("foo", arg => NULL, date_string =...
                                                   ^
==

# Invalid function call with a mix of positional and named arguments, where one
# of the positional arguments corresponds to an argument type declaration in the
# function signature with the same name as one of the provided named arguments.
select fn_named_args("%x", format_string => "%x")
--
ERROR: Named argument format_string is invalid because this call to function sample_functions:fn_named_args also includes a positional argument corresponding to the same name in the function signature [at 1:28]
select fn_named_args("%x", format_string => "%x")
                           ^
==

# Invalid function call with a mix of positional and named arguments, where one
# of the positional arguments corresponds to an argument type declaration in the
# function signature with the same name as one of the provided named arguments.
select fn_named_args("%x", format_string => "%x", date_string => "12/25/08")
--
ERROR: Number of arguments does not match for function SAMPLE_FUNCTIONS:FN_NAMED_ARGS. Supported signature: FN_NAMED_ARGS(STRING, STRING) [at 1:8]
select fn_named_args("%x", format_string => "%x", date_string => "12/25/08")
       ^
==

# Invalid TVF call with one relation named argument: an extra argument name is
# provided.
select * from tvf_named_required_any_relation_arg(
    any_relation_arg => (select 1 as x), extra_arg => 42)
--
ERROR: Named argument extra_arg not found in signature for call to function tvf_named_required_any_relation_arg [at 2:42]
    any_relation_arg => (select 1 as x), extra_arg => 42)
                                         ^
==

# Invalid TVF call with one relation named argument: a scalar value is provided.
select * from tvf_named_required_any_relation_arg(
    any_relation_arg => 42)
--
ERROR: Table-valued function tvf_named_required_any_relation_arg argument 1 ('any_relation_arg') must be a relation (i.e. table subquery) [at 2:25]
    any_relation_arg => 42)
                        ^
==

# Invalid TVF call with one relation named argument: the wrong schema is
# provided.
select * from tvf_named_required_schema_relation_arg(
    schema_relation_arg => (select * from keyvalue))
--
ERROR: Function does not allow extra input column named "Key" for argument 1 of TVF_NAMED_REQUIRED_SCHEMA_RELATION_ARG(TABLE<column_bool BOOL, column_bytes BYTES>) [at 2:5]
    schema_relation_arg => (select * from keyvalue))
    ^
==

# Invalid TVF call with two scalar named arguments: a required argument name is
# missing.
select * from tvf_named_required_scalar_args(
    format_string => "%X")
--
ERROR: No matching signature for tvf_named_required_scalar_args for argument types: STRING. Supported signature: TVF_NAMED_REQUIRED_SCALAR_ARGS(STRING, STRING) [at 1:15]
select * from tvf_named_required_scalar_args(
              ^
==

# Invalid TVF call with two scalar named arguments: an extra argument name is
# provided.
select * from tvf_named_required_scalar_args(
    format_string => "%X", date_string => "12/25/08", extra_arg => 42)
--
ERROR: Named argument extra_arg not found in signature for call to function tvf_named_required_scalar_args [at 2:55]
    format_string => "%X", date_string => "12/25/08", extra_arg => 42)
                                                      ^
==

# The TVF call provides named arguments with scalar values but the function
# signature does not indicate any required argument names.
select * from tvf_exactly_3_int64_args(first => 1, second => 2, third => 3)
--
ERROR: Named argument first not found in signature for call to function tvf_exactly_3_int64_args [at 1:40]
select * from tvf_exactly_3_int64_args(first => 1, second => 2, third => 3)
                                       ^
==

# Invalid TVF call with a mix of positional and named arguments, where one
# of the positional arguments corresponds to an argument type declaration in the
# function signature with the same name as one of the provided named arguments.
select *
from tvf_named_optional_scalar_args("abc", "def", format_string => "hgi")
--
ERROR: No matching signature for tvf_named_optional_scalar_args for argument types: STRING, STRING, STRING. Supported signature: TVF_NAMED_OPTIONAL_SCALAR_ARGS([STRING], [STRING]) [at 2:6]
from tvf_named_optional_scalar_args("abc", "def", format_string => "hgi")
     ^
==

# Invalid TVF call with a mix of positional and named arguments, where one
# of the positional arguments corresponds to an argument type declaration in the
# function signature with the same name as one of the provided named arguments.
select *
from tvf_named_optional_scalar_args("abc", "def", date_string => "hgi")
--
ERROR: No matching signature for tvf_named_optional_scalar_args for argument types: STRING, STRING, STRING. Supported signature: TVF_NAMED_OPTIONAL_SCALAR_ARGS([STRING], [STRING]) [at 2:6]
from tvf_named_optional_scalar_args("abc", "def", date_string => "hgi")
     ^
==

# Invalid TVF call with a mix of positional and named arguments, where one
# of the positional arguments corresponds to an argument type declaration in the
# function signature with the same name as one of the provided named arguments.
select * from tvf_named_optional_any_relation_arg_optional_scalar_arg(
    (select 2 as y), any_relation_arg => (select 1 as x), format_string => 42)
--
ERROR: No matching signature for tvf_named_optional_any_relation_arg_optional_scalar_arg for argument types: TABLE<y INT64>, TABLE<x INT64>, INT64. Supported signature: TVF_NAMED_OPTIONAL_ANY_RELATION_ARG_OPTIONAL_SCALAR_ARG([TABLE], [STRING]) [at 1:15]
select * from tvf_named_optional_any_relation_arg_optional_scalar_arg(
              ^
==

# The TVF call provides a named argument with a relation value but the function
# signature does not indicate any required argument names.
select * from tvf_one_relation_arg_with_fixed_output(
  name => (select cast(42 as bool) as bool_column))
--
ERROR: Named argument name not found in signature for call to function tvf_one_relation_arg_with_fixed_output [at 2:3]
  name => (select cast(42 as bool) as bool_column))
  ^
==

# Invalid function call with a duplicate provided argument name.
select fn_named_args(
    format_string => "%X", date_string => "12/24/08", date_string => "12/25/08")
--
ERROR: Number of arguments does not match for function SAMPLE_FUNCTIONS:FN_NAMED_ARGS. Supported signature: FN_NAMED_ARGS(STRING, STRING) [at 1:8]
select fn_named_args(
       ^
==

# Invalid function call with a provided argument name not found in the function
# signature.
select fn_named_args(bad_name => "12/25/08")
--
ERROR: Number of arguments does not match for function SAMPLE_FUNCTIONS:FN_NAMED_ARGS. Supported signature: FN_NAMED_ARGS(STRING, STRING) [at 1:8]
select fn_named_args(bad_name => "12/25/08")
       ^
==

# Invalid function call with a provided argument name not found in the function
# signature, but also includes all the valid argument names.
select fn_named_args(
    format_string => "%X", date_string => "12/25/08", bad_name => "12/25/08")
--
ERROR: Number of arguments does not match for function SAMPLE_FUNCTIONS:FN_NAMED_ARGS. Supported signature: FN_NAMED_ARGS(STRING, STRING) [at 1:8]
select fn_named_args(
       ^
==

# Invalid function call with a provided argument name not found in the function
# signature, but also includes some of the valid argument names.
select fn_named_args(
    format_string => "%X", bad_name => "12/25/08")
--
ERROR: Named argument bad_name not found in signature for call to function sample_functions:fn_named_args [at 2:28]
    format_string => "%X", bad_name => "12/25/08")
                           ^
==

# Invalid function call with a positional argument following a named argument.
select fn_named_args(format_string => "%x", "12/25/08")
--
ERROR: Call to function sample_functions:fn_named_args must not specify positional arguments after named arguments; named arguments must be specified last in the argument list [at 1:22]
select fn_named_args(format_string => "%x", "12/25/08")
                     ^
==

# Invalid function call with a positional argument following a named argument.
select fn_named_args(format_string => "%x", "12/25/08", date_string => "%X")
--
ERROR: Number of arguments does not match for function SAMPLE_FUNCTIONS:FN_NAMED_ARGS. Supported signature: FN_NAMED_ARGS(STRING, STRING) [at 1:8]
select fn_named_args(format_string => "%x", "12/25/08", date_string => "%X")
       ^
==

# Invalid function call missing a required argument.
select fn_named_args(format_string => "%x")
--
ERROR: Number of arguments does not match for function SAMPLE_FUNCTIONS:FN_NAMED_ARGS. Supported signature: FN_NAMED_ARGS(STRING, STRING) [at 1:8]
select fn_named_args(format_string => "%x")
       ^
==

# The language feature is not enabled.
[language_features=]
select fn_named_args(format_string => "%x", date_string => "12/25/08")
--
ERROR: Named arguments are not supported [at 1:22]
select fn_named_args(format_string => "%x", date_string => "12/25/08")
                     ^
==

# The language feature is not enabled.
[language_features=]
select * from tvf_exactly_3_int64_args(first => 1, second => 2, third => 3)
--
ERROR: Table-valued functions are not supported [at 1:15]
select * from tvf_exactly_3_int64_args(first => 1, second => 2, third => 3)
              ^
==

# Error message with named argument
select fn_const_named_arg(date_string => "12/25/08", Format_String => x) from unnest(["a", "b"]) x
--
ERROR: Argument 'format_string' to SAMPLE_FUNCTIONS:FN_CONST_NAMED_ARG must be a literal or query parameter [at 1:54]
select fn_const_named_arg(date_string => "12/25/08", Format_String => x) from...
                                                     ^
==

# Error message with positional argument
select fn_const_named_arg(x, "12/25/08") from unnest(["a", "b"]) x
--
ERROR: Argument 1 to SAMPLE_FUNCTIONS:FN_CONST_NAMED_ARG must be a literal or query parameter [at 1:27]
select fn_const_named_arg(x, "12/25/08") from unnest(["a", "b"]) x
                          ^
==

# Call to a function that provides two similar signatures, one with regular
# argument, and one with named argument of same type.
select fn_regular_and_named_signatures("foo")
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_regular_and_named_signatures(STRING, optional(0) STRING) -> BOOL)
    |     +-Literal(type=STRING, value="foo")
    +-input_scan=
      +-SingleRowScan
==

# Call to a function that provides two similar signatures, one with regular
# argument, and one with named argument of same type.
select fn_regular_and_named_signatures("foo", "bar")
--

QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_regular_and_named_signatures(STRING, optional(1) STRING) -> BOOL)
    |     +-Literal(type=STRING, value="foo")
    |     +-Literal(type=STRING, value="bar")
    +-input_scan=
      +-SingleRowScan
==

# Call to a function that provides two similar signatures, one with regular
# argument, and one with named argument of same type.
select fn_regular_and_named_signatures("foo", date_string => "bar")
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_regular_and_named_signatures(STRING, optional(1) STRING date_string) -> BOOL)
    |     +-Literal(type=STRING, value="foo")
    |     +-Literal(type=STRING, value="bar")
    +-input_scan=
      +-SingleRowScan
==

# Invalid call to a function that provides two similar signatures, one with
# regular argument, and one with named argument of same type.
select fn_regular_and_named_signatures("foo", "bar", date_string => "baz")
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_REGULAR_AND_NAMED_SIGNATURES for argument types: STRING, STRING, STRING. Supported signatures: FN_REGULAR_AND_NAMED_SIGNATURES(STRING, [STRING]); FN_REGULAR_AND_NAMED_SIGNATURES(STRING, [date_string => STRING]) [at 1:8]
select fn_regular_and_named_signatures("foo", "bar", date_string => "baz")
       ^
==

# Invalid call to a function that provides two similar signatures, one with
# regular argument, and one with named argument of same type.
select fn_regular_and_named_signatures("foo", unknown_arg => "baz")
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_REGULAR_AND_NAMED_SIGNATURES for argument types: STRING, STRING. Supported signatures: FN_REGULAR_AND_NAMED_SIGNATURES(STRING, [STRING]); FN_REGULAR_AND_NAMED_SIGNATURES(STRING, [date_string => STRING]) [at 1:8]
select fn_regular_and_named_signatures("foo", unknown_arg => "baz")
       ^
==

# Call to the 'fn_rep_opt' function which has multiple repeated and optional
# arguments with all positional arguments.
SELECT
 fn_rep_opt("a0", "a1"),
 fn_rep_opt("a0", "r0", "r1", "r2", "a1"),
 fn_rep_opt("a0", "r0", "r1", "r2", "r0-1", "r1-1", "r2-1", "a1"),
 fn_rep_opt("a0", "a1", "o0"),
 fn_rep_opt("a0", "a1", "o0", "o1");
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
| +-$query.$col2#2 AS `$col2` [INT64]
| +-$query.$col3#3 AS `$col3` [INT64]
| +-$query.$col4#4 AS `$col4` [INT64]
| +-$query.$col5#5 AS `$col5` [INT64]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2, $col3#3, $col4#4, $col5#5]
    +-expr_list=
    | +-$col1#1 :=
    | | +-FunctionCall(sample_functions:fn_rep_opt(STRING a0, repeated(0) STRING r0, repeated(0) STRING r1, repeated(0) STRING r2, STRING a1, optional(1) STRING o0, optional(1) STRING o1) -> INT64)
    | |   +-Literal(type=STRING, value="a0")
    | |   +-Literal(type=STRING, value="a1")
    | |   +-Literal(type=STRING, value=NULL)
    | |   +-Literal(type=STRING, value=NULL)
    | +-$col2#2 :=
    | | +-FunctionCall(sample_functions:fn_rep_opt(STRING a0, repeated(1) STRING r0, repeated(1) STRING r1, repeated(1) STRING r2, STRING a1, optional(1) STRING o0, optional(1) STRING o1) -> INT64)
    | |   +-Literal(type=STRING, value="a0")
    | |   +-Literal(type=STRING, value="r0")
    | |   +-Literal(type=STRING, value="r1")
    | |   +-Literal(type=STRING, value="r2")
    | |   +-Literal(type=STRING, value="a1")
    | |   +-Literal(type=STRING, value=NULL)
    | |   +-Literal(type=STRING, value=NULL)
    | +-$col3#3 :=
    | | +-FunctionCall(sample_functions:fn_rep_opt(STRING a0, repeated(2) STRING r0, repeated(2) STRING r1, repeated(2) STRING r2, STRING a1, optional(1) STRING o0, optional(1) STRING o1) -> INT64)
    | |   +-Literal(type=STRING, value="a0")
    | |   +-Literal(type=STRING, value="r0")
    | |   +-Literal(type=STRING, value="r1")
    | |   +-Literal(type=STRING, value="r2")
    | |   +-Literal(type=STRING, value="r0-1")
    | |   +-Literal(type=STRING, value="r1-1")
    | |   +-Literal(type=STRING, value="r2-1")
    | |   +-Literal(type=STRING, value="a1")
    | |   +-Literal(type=STRING, value=NULL)
    | |   +-Literal(type=STRING, value=NULL)
    | +-$col4#4 :=
    | | +-FunctionCall(sample_functions:fn_rep_opt(STRING a0, repeated(0) STRING r0, repeated(0) STRING r1, repeated(0) STRING r2, STRING a1, optional(1) STRING o0, optional(1) STRING o1) -> INT64)
    | |   +-Literal(type=STRING, value="a0")
    | |   +-Literal(type=STRING, value="a1")
    | |   +-Literal(type=STRING, value="o0")
    | |   +-Literal(type=STRING, value=NULL)
    | +-$col5#5 :=
    |   +-FunctionCall(sample_functions:fn_rep_opt(STRING a0, repeated(0) STRING r0, repeated(0) STRING r1, repeated(0) STRING r2, STRING a1, optional(1) STRING o0, optional(1) STRING o1) -> INT64)
    |     +-Literal(type=STRING, value="a0")
    |     +-Literal(type=STRING, value="a1")
    |     +-Literal(type=STRING, value="o0")
    |     +-Literal(type=STRING, value="o1")
    +-input_scan=
      +-SingleRowScan
==

# Call to the 'fn_rep_opt' function which has multiple repeated and optional
# arguments with positional and named arguments, but does not specify the
# repeated arguments.
SELECT
 fn_rep_opt("a0", a1 => "a1"),
 fn_rep_opt("a0", a1 => "a1", o0 => "o0"),
 fn_rep_opt("a0", a1 => "a1", o1 => "o1"),
 fn_rep_opt("a0", o0 => "o0", a1 => "a1"),
 fn_rep_opt("a0", o1 => "o1", a1 => "a1"),
 fn_rep_opt("a0", o1 => "o1", o0 => "o0", a1 => "a1");
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
| +-$query.$col2#2 AS `$col2` [INT64]
| +-$query.$col3#3 AS `$col3` [INT64]
| +-$query.$col4#4 AS `$col4` [INT64]
| +-$query.$col5#5 AS `$col5` [INT64]
| +-$query.$col6#6 AS `$col6` [INT64]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2, $col3#3, $col4#4, $col5#5, $col6#6]
    +-expr_list=
    | +-$col1#1 :=
    | | +-FunctionCall(sample_functions:fn_rep_opt(STRING a0, repeated(0) STRING r0, repeated(0) STRING r1, repeated(0) STRING r2, STRING a1, optional(1) STRING o0, optional(1) STRING o1) -> INT64)
    | |   +-Literal(type=STRING, value="a0")
    | |   +-Literal(type=STRING, value="a1")
    | |   +-Literal(type=STRING, value=NULL)
    | |   +-Literal(type=STRING, value=NULL)
    | +-$col2#2 :=
    | | +-FunctionCall(sample_functions:fn_rep_opt(STRING a0, repeated(0) STRING r0, repeated(0) STRING r1, repeated(0) STRING r2, STRING a1, optional(1) STRING o0, optional(1) STRING o1) -> INT64)
    | |   +-Literal(type=STRING, value="a0")
    | |   +-Literal(type=STRING, value="a1")
    | |   +-Literal(type=STRING, value="o0")
    | |   +-Literal(type=STRING, value=NULL)
    | +-$col3#3 :=
    | | +-FunctionCall(sample_functions:fn_rep_opt(STRING a0, repeated(0) STRING r0, repeated(0) STRING r1, repeated(0) STRING r2, STRING a1, optional(1) STRING o0, optional(1) STRING o1) -> INT64)
    | |   +-Literal(type=STRING, value="a0")
    | |   +-Literal(type=STRING, value="a1")
    | |   +-Literal(type=STRING, value=NULL)
    | |   +-Literal(type=STRING, value="o1")
    | +-$col4#4 :=
    | | +-FunctionCall(sample_functions:fn_rep_opt(STRING a0, repeated(0) STRING r0, repeated(0) STRING r1, repeated(0) STRING r2, STRING a1, optional(1) STRING o0, optional(1) STRING o1) -> INT64)
    | |   +-Literal(type=STRING, value="a0")
    | |   +-Literal(type=STRING, value="a1")
    | |   +-Literal(type=STRING, value="o0")
    | |   +-Literal(type=STRING, value=NULL)
    | +-$col5#5 :=
    | | +-FunctionCall(sample_functions:fn_rep_opt(STRING a0, repeated(0) STRING r0, repeated(0) STRING r1, repeated(0) STRING r2, STRING a1, optional(1) STRING o0, optional(1) STRING o1) -> INT64)
    | |   +-Literal(type=STRING, value="a0")
    | |   +-Literal(type=STRING, value="a1")
    | |   +-Literal(type=STRING, value=NULL)
    | |   +-Literal(type=STRING, value="o1")
    | +-$col6#6 :=
    |   +-FunctionCall(sample_functions:fn_rep_opt(STRING a0, repeated(0) STRING r0, repeated(0) STRING r1, repeated(0) STRING r2, STRING a1, optional(1) STRING o0, optional(1) STRING o1) -> INT64)
    |     +-Literal(type=STRING, value="a0")
    |     +-Literal(type=STRING, value="a1")
    |     +-Literal(type=STRING, value="o0")
    |     +-Literal(type=STRING, value="o1")
    +-input_scan=
      +-SingleRowScan
==

# Call to the 'fn_rep_opt' function which has multiple repeated and optional
# arguments with positional and named arguments, including the repeated
# arguments.
SELECT
 fn_rep_opt("a0", "r0", "r1", "r2", a1 => "a1"),
 fn_rep_opt("a0", "r0", "r1", "r2", "r0", "r1", "r2", a1 => "a1", o0 => "o0"),
 fn_rep_opt("a0", "r0", "r1", "r2", a1 => "a1", o1 => "o1"),
 fn_rep_opt("a0", "r0", "r1", "r2", "r0", "r1", "r2", "r0", "r1", "r2",
            o0 => "o0", a1 => "a1"),
 fn_rep_opt("a0", "r0", "r1", "r2", o1 => "o1", a1 => "a1"),
 fn_rep_opt("a0", "r0", "r1", "r2", o1 => "o1", o0 => "o0", a1 => "a1");
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
| +-$query.$col2#2 AS `$col2` [INT64]
| +-$query.$col3#3 AS `$col3` [INT64]
| +-$query.$col4#4 AS `$col4` [INT64]
| +-$query.$col5#5 AS `$col5` [INT64]
| +-$query.$col6#6 AS `$col6` [INT64]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2, $col3#3, $col4#4, $col5#5, $col6#6]
    +-expr_list=
    | +-$col1#1 :=
    | | +-FunctionCall(sample_functions:fn_rep_opt(STRING a0, repeated(1) STRING r0, repeated(1) STRING r1, repeated(1) STRING r2, STRING a1, optional(1) STRING o0, optional(1) STRING o1) -> INT64)
    | |   +-Literal(type=STRING, value="a0")
    | |   +-Literal(type=STRING, value="r0")
    | |   +-Literal(type=STRING, value="r1")
    | |   +-Literal(type=STRING, value="r2")
    | |   +-Literal(type=STRING, value="a1")
    | |   +-Literal(type=STRING, value=NULL)
    | |   +-Literal(type=STRING, value=NULL)
    | +-$col2#2 :=
    | | +-FunctionCall(sample_functions:fn_rep_opt(STRING a0, repeated(2) STRING r0, repeated(2) STRING r1, repeated(2) STRING r2, STRING a1, optional(1) STRING o0, optional(1) STRING o1) -> INT64)
    | |   +-Literal(type=STRING, value="a0")
    | |   +-Literal(type=STRING, value="r0")
    | |   +-Literal(type=STRING, value="r1")
    | |   +-Literal(type=STRING, value="r2")
    | |   +-Literal(type=STRING, value="r0")
    | |   +-Literal(type=STRING, value="r1")
    | |   +-Literal(type=STRING, value="r2")
    | |   +-Literal(type=STRING, value="a1")
    | |   +-Literal(type=STRING, value="o0")
    | |   +-Literal(type=STRING, value=NULL)
    | +-$col3#3 :=
    | | +-FunctionCall(sample_functions:fn_rep_opt(STRING a0, repeated(1) STRING r0, repeated(1) STRING r1, repeated(1) STRING r2, STRING a1, optional(1) STRING o0, optional(1) STRING o1) -> INT64)
    | |   +-Literal(type=STRING, value="a0")
    | |   +-Literal(type=STRING, value="r0")
    | |   +-Literal(type=STRING, value="r1")
    | |   +-Literal(type=STRING, value="r2")
    | |   +-Literal(type=STRING, value="a1")
    | |   +-Literal(type=STRING, value=NULL)
    | |   +-Literal(type=STRING, value="o1")
    | +-$col4#4 :=
    | | +-FunctionCall(sample_functions:fn_rep_opt(STRING a0, repeated(3) STRING r0, repeated(3) STRING r1, repeated(3) STRING r2, STRING a1, optional(1) STRING o0, optional(1) STRING o1) -> INT64)
    | |   +-Literal(type=STRING, value="a0")
    | |   +-Literal(type=STRING, value="r0")
    | |   +-Literal(type=STRING, value="r1")
    | |   +-Literal(type=STRING, value="r2")
    | |   +-Literal(type=STRING, value="r0")
    | |   +-Literal(type=STRING, value="r1")
    | |   +-Literal(type=STRING, value="r2")
    | |   +-Literal(type=STRING, value="r0")
    | |   +-Literal(type=STRING, value="r1")
    | |   +-Literal(type=STRING, value="r2")
    | |   +-Literal(type=STRING, value="a1")
    | |   +-Literal(type=STRING, value="o0")
    | |   +-Literal(type=STRING, value=NULL)
    | +-$col5#5 :=
    | | +-FunctionCall(sample_functions:fn_rep_opt(STRING a0, repeated(1) STRING r0, repeated(1) STRING r1, repeated(1) STRING r2, STRING a1, optional(1) STRING o0, optional(1) STRING o1) -> INT64)
    | |   +-Literal(type=STRING, value="a0")
    | |   +-Literal(type=STRING, value="r0")
    | |   +-Literal(type=STRING, value="r1")
    | |   +-Literal(type=STRING, value="r2")
    | |   +-Literal(type=STRING, value="a1")
    | |   +-Literal(type=STRING, value=NULL)
    | |   +-Literal(type=STRING, value="o1")
    | +-$col6#6 :=
    |   +-FunctionCall(sample_functions:fn_rep_opt(STRING a0, repeated(1) STRING r0, repeated(1) STRING r1, repeated(1) STRING r2, STRING a1, optional(1) STRING o0, optional(1) STRING o1) -> INT64)
    |     +-Literal(type=STRING, value="a0")
    |     +-Literal(type=STRING, value="r0")
    |     +-Literal(type=STRING, value="r1")
    |     +-Literal(type=STRING, value="r2")
    |     +-Literal(type=STRING, value="a1")
    |     +-Literal(type=STRING, value="o0")
    |     +-Literal(type=STRING, value="o1")
    +-input_scan=
      +-SingleRowScan
==

# An invalid function call: a named argument notation comes before a positional
# arguments.
SELECT fn_rep_opt("a0", "r0", "r1", a1 => "a1", "r2");
--
ERROR: Call to function sample_functions:fn_rep_opt must not specify positional arguments after named arguments; named arguments must be specified last in the argument list [at 1:37]
SELECT fn_rep_opt("a0", "r0", "r1", a1 => "a1", "r2");
                                    ^
==

# An invalid function call: the required named argument "a1" is omitted.
SELECT fn_rep_opt("a0", "r0", "r1", "r2", o0 => "o0", o1 => "o1");
--
ERROR: Call to function sample_functions:fn_rep_opt does not include the required named argument 'a1' [at 1:8]
SELECT fn_rep_opt("a0", "r0", "r1", "r2", o0 => "o0", o1 => "o1");
       ^
==

# Valid function calls with the signature like:
#   fn_req_opt_unnamed_named(
#       STRING, optional STRING, optional o1 STRING)
# This is to test if the resolver can handle mix of unnamed and named arguments
# correctly.
SELECT
  fn_req_opt_unnamed_named("abc"),
  fn_req_opt_unnamed_named("abc", "def"),
  fn_req_opt_unnamed_named("abc", "def", "ghi"),
  fn_req_opt_unnamed_named("abc", o1 => "ghi"),
  fn_req_opt_unnamed_named("abc", "def", o1 => "ghi");
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
| +-$query.$col2#2 AS `$col2` [INT64]
| +-$query.$col3#3 AS `$col3` [INT64]
| +-$query.$col4#4 AS `$col4` [INT64]
| +-$query.$col5#5 AS `$col5` [INT64]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2, $col3#3, $col4#4, $col5#5]
    +-expr_list=
    | +-$col1#1 :=
    | | +-FunctionCall(sample_functions:fn_req_opt_unnamed_named(STRING, optional(1) STRING, optional(1) STRING o1) -> INT64)
    | |   +-Literal(type=STRING, value="abc")
    | |   +-Literal(type=STRING, value=NULL)
    | |   +-Literal(type=STRING, value=NULL)
    | +-$col2#2 :=
    | | +-FunctionCall(sample_functions:fn_req_opt_unnamed_named(STRING, optional(1) STRING, optional(1) STRING o1) -> INT64)
    | |   +-Literal(type=STRING, value="abc")
    | |   +-Literal(type=STRING, value="def")
    | |   +-Literal(type=STRING, value=NULL)
    | +-$col3#3 :=
    | | +-FunctionCall(sample_functions:fn_req_opt_unnamed_named(STRING, optional(1) STRING, optional(1) STRING o1) -> INT64)
    | |   +-Literal(type=STRING, value="abc")
    | |   +-Literal(type=STRING, value="def")
    | |   +-Literal(type=STRING, value="ghi")
    | +-$col4#4 :=
    | | +-FunctionCall(sample_functions:fn_req_opt_unnamed_named(STRING, optional(1) STRING, optional(1) STRING o1) -> INT64)
    | |   +-Literal(type=STRING, value="abc")
    | |   +-Literal(type=STRING, value=NULL)
    | |   +-Literal(type=STRING, value="ghi")
    | +-$col5#5 :=
    |   +-FunctionCall(sample_functions:fn_req_opt_unnamed_named(STRING, optional(1) STRING, optional(1) STRING o1) -> INT64)
    |     +-Literal(type=STRING, value="abc")
    |     +-Literal(type=STRING, value="def")
    |     +-Literal(type=STRING, value="ghi")
    +-input_scan=
      +-SingleRowScan
==

# Valid function calls with the signature like:
#   tvf_optional_unnamed_named(
#       ANY TABLE, BOOL, optional STRING, optional o1 STRING)
# This is to test if the resolver can handle mix of unnamed and named arguments
# correctly.
#
# TODO: Note that unlike the scalar function case above, NULLs are not
# injected when some trailing optional arguments are omitted, even if some of
# them are named. This is an existing confusing behavior. We need to fix it
# afterwards.
SELECT *
FROM tvf_optional_unnamed_named((SELECT 1 as x), true)
UNION ALL
SELECT *
FROM tvf_optional_unnamed_named((SELECT 1 as x), true, "abc")
UNION ALL
SELECT *
FROM tvf_optional_unnamed_named((SELECT 1 as x), true, "abc", "def")
UNION ALL
SELECT *
FROM tvf_optional_unnamed_named((SELECT 1 as x), true, "abc", o1 => "def")
--
QueryStmt
+-output_column_list=
| +-$union_all.x#9 AS x [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.x#9]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[tvf_optional_unnamed_named.x#2]
      | |   +-input_scan=
      | |     +-TVFScan
      | |       +-column_list=[tvf_optional_unnamed_named.x#2]
      | |       +-tvf=tvf_optional_unnamed_named((ANY TABLE, BOOL, optional STRING, optional STRING o1) -> ANY TABLE)
      | |       +-signature=(TABLE<x INT64>, literal BOOL) -> TABLE<x INT64>
      | |       +-argument_list=
      | |       | +-FunctionArgument
      | |       | | +-scan=
      | |       | | | +-ProjectScan
      | |       | | |   +-column_list=[$subquery1.x#1]
      | |       | | |   +-expr_list=
      | |       | | |   | +-x#1 := Literal(type=INT64, value=1)
      | |       | | |   +-input_scan=
      | |       | | |     +-SingleRowScan
      | |       | | +-argument_column_list=[$subquery1.x#1]
      | |       | +-FunctionArgument
      | |       |   +-expr=
      | |       |     +-Literal(type=BOOL, value=true)
      | |       +-column_index_list=[0]
      | +-output_column_list=[tvf_optional_unnamed_named.x#2]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[tvf_optional_unnamed_named.x#4]
      | |   +-input_scan=
      | |     +-TVFScan
      | |       +-column_list=[tvf_optional_unnamed_named.x#4]
      | |       +-tvf=tvf_optional_unnamed_named((ANY TABLE, BOOL, optional STRING, optional STRING o1) -> ANY TABLE)
      | |       +-signature=(TABLE<x INT64>, literal BOOL, literal STRING) -> TABLE<x INT64>
      | |       +-argument_list=
      | |       | +-FunctionArgument
      | |       | | +-scan=
      | |       | | | +-ProjectScan
      | |       | | |   +-column_list=[$subquery2.x#3]
      | |       | | |   +-expr_list=
      | |       | | |   | +-x#3 := Literal(type=INT64, value=1)
      | |       | | |   +-input_scan=
      | |       | | |     +-SingleRowScan
      | |       | | +-argument_column_list=[$subquery2.x#3]
      | |       | +-FunctionArgument
      | |       | | +-expr=
      | |       | |   +-Literal(type=BOOL, value=true)
      | |       | +-FunctionArgument
      | |       |   +-expr=
      | |       |     +-Literal(type=STRING, value="abc")
      | |       +-column_index_list=[0]
      | +-output_column_list=[tvf_optional_unnamed_named.x#4]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[tvf_optional_unnamed_named.x#6]
      | |   +-input_scan=
      | |     +-TVFScan
      | |       +-column_list=[tvf_optional_unnamed_named.x#6]
      | |       +-tvf=tvf_optional_unnamed_named((ANY TABLE, BOOL, optional STRING, optional STRING o1) -> ANY TABLE)
      | |       +-signature=(TABLE<x INT64>, literal BOOL, literal STRING, literal STRING) -> TABLE<x INT64>
      | |       +-argument_list=
      | |       | +-FunctionArgument
      | |       | | +-scan=
      | |       | | | +-ProjectScan
      | |       | | |   +-column_list=[$subquery3.x#5]
      | |       | | |   +-expr_list=
      | |       | | |   | +-x#5 := Literal(type=INT64, value=1)
      | |       | | |   +-input_scan=
      | |       | | |     +-SingleRowScan
      | |       | | +-argument_column_list=[$subquery3.x#5]
      | |       | +-FunctionArgument
      | |       | | +-expr=
      | |       | |   +-Literal(type=BOOL, value=true)
      | |       | +-FunctionArgument
      | |       | | +-expr=
      | |       | |   +-Literal(type=STRING, value="abc")
      | |       | +-FunctionArgument
      | |       |   +-expr=
      | |       |     +-Literal(type=STRING, value="def")
      | |       +-column_index_list=[0]
      | +-output_column_list=[tvf_optional_unnamed_named.x#6]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[tvf_optional_unnamed_named.x#8]
        |   +-input_scan=
        |     +-TVFScan
        |       +-column_list=[tvf_optional_unnamed_named.x#8]
        |       +-tvf=tvf_optional_unnamed_named((ANY TABLE, BOOL, optional STRING, optional STRING o1) -> ANY TABLE)
        |       +-signature=(TABLE<x INT64>, literal BOOL, literal STRING, literal STRING) -> TABLE<x INT64>
        |       +-argument_list=
        |       | +-FunctionArgument
        |       | | +-scan=
        |       | | | +-ProjectScan
        |       | | |   +-column_list=[$subquery4.x#7]
        |       | | |   +-expr_list=
        |       | | |   | +-x#7 := Literal(type=INT64, value=1)
        |       | | |   +-input_scan=
        |       | | |     +-SingleRowScan
        |       | | +-argument_column_list=[$subquery4.x#7]
        |       | +-FunctionArgument
        |       | | +-expr=
        |       | |   +-Literal(type=BOOL, value=true)
        |       | +-FunctionArgument
        |       | | +-expr=
        |       | |   +-Literal(type=STRING, value="abc")
        |       | +-FunctionArgument
        |       |   +-expr=
        |       |     +-Literal(type=STRING, value="def")
        |       +-column_index_list=[0]
        +-output_column_list=[tvf_optional_unnamed_named.x#8]
==

# Regression test against b/182060963: Make sure the AST location of TVF
# arguments are correctly passed to FunctionResolver::AddCastOrConvertLiteral.
#
# The TVF signature is like:
#   tvf_named_struct_args(
#       struct_arg1 STRUCT<field1 ARRAY<STRING>, field2 ARRAY<STRING>>,
#       struct_arg2 STRUCT<field1 ARRAY<STRING>,
#                          field2 ARRAY<STRING>,
#                          field3 ARRAY<STRING>)
#
# Note the TVF call here specifies a wrong struct field name ('field2__'
# instead of 'field2').
SELECT * FROM tvf_named_struct_args(
    struct_arg2 => STRUCT(
        [""] AS field1,
        (ARRAY(SELECT v FROM UNNEST([""]) v WHERE v <> "")) AS field2__,
        [""] AS field3),
    struct_arg1 => STRUCT([""] AS field1, ["A","B"]AS field2));
--
QueryStmt
+-output_column_list=
| +-tvf_named_struct_args.column_bool#2 AS column_bool [BOOL]
| +-tvf_named_struct_args.column_bytes#3 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_named_struct_args.[column_bool#2, column_bytes#3]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_named_struct_args.[column_bool#2, column_bytes#3]
        +-tvf=tvf_named_struct_args((STRUCT<field1 ARRAY<STRING>, field2 ARRAY<STRING>> struct_arg1, STRUCT<field1 ARRAY<STRING>, field2 ARRAY<STRING>, field3 ARRAY<STRING>> struct_arg2) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(STRUCT<field1 ARRAY<STRING>, field2 ARRAY<STRING>>, STRUCT<field1 ARRAY<STRING>, field2 ARRAY<STRING>, field3 ARRAY<STRING>>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=STRUCT<field1 ARRAY<STRING>, field2 ARRAY<STRING>>, value={field1:[""], field2:["A", "B"]})
        | +-FunctionArgument
        |   +-expr=
        |     +-MakeStruct
        |       +-type=STRUCT<field1 ARRAY<STRING>, field2 ARRAY<STRING>, field3 ARRAY<STRING>>
        |       +-field_list=
        |         +-Literal(type=ARRAY<STRING>, value=[""])
        |         +-SubqueryExpr
        |         | +-type=ARRAY<STRING>
        |         | +-subquery_type=ARRAY
        |         | +-subquery=
        |         |   +-ProjectScan
        |         |     +-column_list=[$array.v#1]
        |         |     +-input_scan=
        |         |       +-FilterScan
        |         |         +-column_list=[$array.v#1]
        |         |         +-input_scan=
        |         |         | +-ArrayScan
        |         |         |   +-column_list=[$array.v#1]
        |         |         |   +-array_expr=
        |         |         |   | +-Literal(type=ARRAY<STRING>, value=[""])
        |         |         |   +-element_column=$array.v#1
        |         |         +-filter_expr=
        |         |           +-FunctionCall(ZetaSQL:$not_equal(STRING, STRING) -> BOOL)
        |         |             +-ColumnRef(type=STRING, column=$array.v#1)
        |         |             +-Literal(type=STRING, value="")
        |         +-Literal(type=ARRAY<STRING>, value=[""])
        +-column_index_list=[0, 1]
==

# Regression test for b/214174087. A templated UDA has a NOT AGGREGATE argument
# with a default value.
SELECT uda_templated_two_not_aggregate_args(col) AS result
FROM UNNEST(['a', 'b', 'c', 'f']) AS col;
--
QueryStmt
+-output_column_list=
| +-$aggregate.result#2 AS result [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.result#2]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.result#2]
        +-input_scan=
        | +-ArrayScan
        |   +-column_list=[$array.col#1]
        |   +-array_expr=
        |   | +-Literal(type=ARRAY<STRING>, value=["a", "b", "c", "f"])
        |   +-element_column=$array.col#1
        +-aggregate_list=
          +-result#2 :=
            +-AggregateFunctionCall(Templated_SQL_Function:uda_templated_two_not_aggregate_args(STRING, optional(1) INT64 delta, optional(1) BOOL allow_nulls) -> STRING)
              +-ColumnRef(type=STRING, column=$array.col#1)
              +-Literal(type=INT64, value=0)
              +-Literal(type=BOOL, value=false)
==

# Regression test for b/214174087. A templated UDA has a NOT AGGREGATE argument
# with a default value.
SELECT uda_templated_two_not_aggregate_args(col, allow_nulls => TRUE) AS result
FROM UNNEST(['a', 'b', 'c', 'f']) AS col;
--
QueryStmt
+-output_column_list=
| +-$aggregate.result#2 AS result [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.result#2]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.result#2]
        +-input_scan=
        | +-ArrayScan
        |   +-column_list=[$array.col#1]
        |   +-array_expr=
        |   | +-Literal(type=ARRAY<STRING>, value=["a", "b", "c", "f"])
        |   +-element_column=$array.col#1
        +-aggregate_list=
          +-result#2 :=
            +-AggregateFunctionCall(Templated_SQL_Function:uda_templated_two_not_aggregate_args(STRING, optional(1) INT64 delta, optional(1) BOOL allow_nulls) -> STRING)
              +-ColumnRef(type=STRING, column=$array.col#1)
              +-Literal(type=INT64, value=0)
              +-Literal(type=BOOL, value=true)
==

# Regression test for b/214174087. A templated UDA has a NOT AGGREGATE argument
# with a default value.
SELECT uda_templated_two_not_aggregate_args(col, 1) AS result
FROM UNNEST(['a', 'b', 'c', 'f']) AS col;
--
QueryStmt
+-output_column_list=
| +-$aggregate.result#2 AS result [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.result#2]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.result#2]
        +-input_scan=
        | +-ArrayScan
        |   +-column_list=[$array.col#1]
        |   +-array_expr=
        |   | +-Literal(type=ARRAY<STRING>, value=["a", "b", "c", "f"])
        |   +-element_column=$array.col#1
        +-aggregate_list=
          +-result#2 :=
            +-AggregateFunctionCall(Templated_SQL_Function:uda_templated_two_not_aggregate_args(STRING, optional(1) INT64 delta, optional(1) BOOL allow_nulls) -> STRING)
              +-ColumnRef(type=STRING, column=$array.col#1)
              +-Literal(type=INT64, value=1)
              +-Literal(type=BOOL, value=false)
==

# Regression test against b/244550962: Make sure the AST location of fields in
# MakeStruct are correctly extracted when the MakeStruct is in an
# ASTNamedArgument.
# Note the function call here specifies a different struct field name ('field2_'
# instead of 'field2') and thus a Cast would be added by the resolver and thus
# trigger the issue in b/244550962.
SELECT fn_named_struct_args(
    struct_arg1 => STRUCT<field1 ARRAY<STRING>, field2 ARRAY<STRING>>(
                       [""], ["A","B"]),
    struct_arg2 =>
      STRUCT<field1 ARRAY<STRING>,
             field2_ ARRAY<STRING>,
             field3 ARRAY<STRING>>(
          [""], ARRAY(SELECT v FROM UNNEST([""]) v WHERE v <> ""), [""])
);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#2 AS `$col1` [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#2]
    +-expr_list=
    | +-$col1#2 :=
    |   +-FunctionCall(sample_functions:fn_named_struct_args(STRUCT<field1 ARRAY<STRING>, field2 ARRAY<STRING>> struct_arg1, STRUCT<field1 ARRAY<STRING>, field2 ARRAY<STRING>, field3 ARRAY<STRING>> struct_arg2) -> ARRAY<STRING>)
    |     +-Literal(type=STRUCT<field1 ARRAY<STRING>, field2 ARRAY<STRING>>, value={field1:[""], field2:["A", "B"]}, has_explicit_type=TRUE)
    |     +-MakeStruct
    |       +-type=STRUCT<field1 ARRAY<STRING>, field2 ARRAY<STRING>, field3 ARRAY<STRING>>
    |       +-field_list=
    |         +-Literal(type=ARRAY<STRING>, value=[""], has_explicit_type=TRUE)
    |         +-SubqueryExpr
    |         | +-type=ARRAY<STRING>
    |         | +-subquery_type=ARRAY
    |         | +-subquery=
    |         |   +-ProjectScan
    |         |     +-column_list=[$array.v#1]
    |         |     +-input_scan=
    |         |       +-FilterScan
    |         |         +-column_list=[$array.v#1]
    |         |         +-input_scan=
    |         |         | +-ArrayScan
    |         |         |   +-column_list=[$array.v#1]
    |         |         |   +-array_expr=
    |         |         |   | +-Literal(type=ARRAY<STRING>, value=[""])
    |         |         |   +-element_column=$array.v#1
    |         |         +-filter_expr=
    |         |           +-FunctionCall(ZetaSQL:$not_equal(STRING, STRING) -> BOOL)
    |         |             +-ColumnRef(type=STRING, column=$array.v#1)
    |         |             +-Literal(type=STRING, value="")
    |         +-Literal(type=ARRAY<STRING>, value=[""], has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
